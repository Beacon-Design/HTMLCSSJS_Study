# CoffeeScript Study Notes



# 0. Getting Started



## 0.1 Study Reference

http://coffeescript.org/

http://coffee-script.org/

http://autotelicum.github.io/Smooth-CoffeeScript/

http://arcturo.github.io/library/coffeescript/index.html





## 0.2 Install 

CoffeeScript 编译器本身[是 CoffeeScript 写的](http://coffee-script.org/documentation/docs/grammar.html), 使用了 [Jison parser generator](http://jison.org/). 命令行版本的 coffee 是一个实用的 [Node.js](http://nodejs.org/) 工具. 不过[编译器](http://coffee-script.org/extras/coffee-script.js)并不依赖 Node, 而是能运行于任何 JavaScript 执行环境。

安装前你需要最新稳定版 [Node.js](http://nodejs.org/), 和 [npm](http://npmjs.org/) (Node Package Manager). 借助 npm 可以安装 CoffeeScript:

**Terminal**


```
sudo npm -g install coffee-script
```
(如果不想全局安装可以去掉 -g 选项.)

**Install Success**

```
/usr/local/bin/coffee -> /usr/local/lib/node_modules/coffee-script/bin/coffee
/usr/local/bin/cake -> /usr/local/lib/node_modules/coffee-script/bin/cake
/usr/local/lib
└── coffee-script@1.12.5 
```



## 0.3 Usage

安装之后, 你应该可以运行 coffee 命令以执行脚本, 编译 .coffee 文件到 .js 文件, 和提供一个交互式的 REPL. coffee 命令有下列参数:

en Version

| Option                   | Description                              |
| ------------------------ | ---------------------------------------- |
| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name. |
| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well. |
| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file. |
| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments. |
| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`. |
| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated. |
| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**. |
| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:`cat src/cake.coffee | coffee -sc` |
| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name. |
| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example:`coffee -e "console.log num for num in [10..1]"` |
| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag. |
| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](http://coffeescript.org/#lexical-scope). |
| `-t, --tokens`           | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler. |
| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler. |
| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times. |
| `--no-header`            | Suppress the “Generated by CoffeeScript” header. |

zh Version:

```
-c  编译一个 .coffee 脚本到一个同名的 .js 文件  
  
-m  随 JavaScript 文件一起生成 source maps. 并且在 JavaScript 里加上sourceMappingURL指令  
  
-i  启动一个交互式的 CoffeeScript 会话用来尝试一些代码片段. 等同于执行 coffee 而不加参数  
  
-o  将所有编译后的 JavaScript 文件写到指定文件夹. 与 --compile 或 --watch 搭配使用  
  
-j  编译之前, 按参数传入顺序连接所有脚本到一起, 编译后写到指定的文件. 对于编译大型项目有用  
  
-w  监视文件改变, 任何文件更新时重新执行命令  
  
-p  直接打印到 stdout 而不是写到一个文件  
  
-s  将CoffeeScript 传递到 STDIN 后从STDOUT 获取 JavaScript. 对其他语言写的进程有好处. 比如:cat src/cake.coffee | coffee -sc  
  
-l  将代码作为 Literate CoffeeScript 解析. 只会在从 stdio 直接传入代码或者处理某些没有后缀的文件名需要写明这点  
  
-e  直接从命令行编译和打印一小段 CoffeeScript. 比如:coffee -e "console.log num for num in [10..1]"  
  
-b  编译到 JavaScript 时去掉顶层函数的包裹  
  
-t  不对 CoffeeScript 进行解析, 仅仅进行 lex, 打印出 token stream: [IDENTIFIER square][ASSIGN =] [PARAM_START (] ...  
  
-n  不对 CoffeeScript 进行编译, 仅仅 lex 和解析, 打印 parse tree:  
    Expressions  
      Assign  
        Value "square"  
        Code "x"  
          Op *  
            Value "x"  
            Value "x"  
```

**例子:**

- 编译一个 .coffee 文件的树形目录 src 到一个同级 .js 文件树形目录 lib:

  ```
  coffee --compile --output lib/ src/
  ```

- 监视一个文件的改变, 每次文件被保证时重新编译:

  ```
  coffee --watch --compile experimental.coffee
  ```

- 合并一组文件到单个脚本:

  ```
  coffee --join project.js --compile src/*.coffee
  ```

- 从一个 one-liner 打印编译后的 JS:

  ```
  coffee -bpe "alert i for i in [0..10]"
  ```

- 现在全部一起, 在你工作时监视和重复编译整个项目:

  ```
  coffee -o lib/ -cw src/
  ```

- 运行 CoffeeScript REPL (Ctrl-D 来终止, Ctrl-V 激活多行):

  ```
  coffee
  ```






## 0.4 Run CoffeeScript 

### Run CoffeeScript in Terminal

```
coffee
```

### Run A CoffeeScript File

1. 新建一个demo.coffee文件。

   1.1 在文件中输入：

   ```coffeescript
   console.log("hello")
   ```

2. 把 demo.coffee 脚本编译成 demo.js 文件。

   2.1 打开 Terminal，命令行进入到 demo.coffee 所在的文件夹下。

   2.2 在 Terminal 中 输入 `coffee -c demo.coffee`

3. 编译成功后，在 demo.coffee 的同文件夹下生成 demo.js 文件。

   3.1 demo.js 文件内容：

   ```javascript
   // Generated by CoffeeScript 1.12.5
   (function() {
     console.log("hello");

   }).call(this);
   ```

4. 执行文件

   4.1 在 Terminal 中 输入 `node demo`

   4.2 在 Terminal 中会看到 "hello"




## 0.5 CoffeeScript IDE

http://stackoverflow.com/questions/14533885/which-ide-supports-coffeescript-debugging-source-mapping-breakpoints-call-st

https://www.jetbrains.com/help/idea/2017.1/debugging-coffeescript.html

**WebStorm**

Webstorm有个file watchers的功能，当你coffee文件有改动，自动帮你编译成js文件。

1. Preferences > Tools > File Watchers > Add CoffeeScript

2. 修改参数：

   默认Arguments参数：

   ```
   --map --compile $FileName$
   ```

   改成如下内容：

   ```
   –bare –compile $FileName$
   ```

   编译后的JavaScript就不会被匿名函数的包裹（之前我们设置的Arguments）






















# 1. Introduction

The golden rule of CoffeeScript is: *“It’s just JavaScript”*.

 The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. 

You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.

**CoffeeScript uses significant whitespace to delimit blocks of code.** 

> You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). 
>
>  **NOT to mix up tabs and spaces**

**use indentation**

> **Instead of using curly braces** `{ }` to surround blocks of code in [functions](http://coffeescript.org/#literals), [if-statements](http://coffeescript.org/#conditionals), [switch](http://coffeescript.org/#switch), and [try/catch](http://coffeescript.org/#try).you can replace curly brackets (`{}`) with a tab. This takes inspiration from Python's syntax, and has the excellent side effect of **ensuring** that your **script is formatted in a sane manner**, **otherwise it won't even compile!**

**Case Sensitive**

> a variable named `box`, it is not the same as `Box`



## Comments 

 starting with a hash character.

```coffeescript
# A comment
```

Multiline comments are enclosed by three hash characters.

```coffeescript
###
  A multiline comment, perhaps a LICENSE.
###
```

> [compiled JavaScript]
>
> ```javascript
> /*
>   A multiline comment, perhaps a LICENSE.
> */
> ```



## Variables & Scope

### Local Variables

variable assignment in CoffeeScript :

```coffeescript
myVariable = "test"
```

> [compiled JavaScript]
>
> ```javascript
> var myVariable;
> myVariable = "test";
> ```

### Global Variables

You can either do this by directly setting them as properties on the global object (`window` in browsers), or with the following pattern:

```coffeescript
exports = this
exports.MyVariable = "foo-bar"
```

> [compiled JavaScript]
>
> ```javascript
> var exports;
> exports = this;
> exports.MyVariable = "foo-bar";
> ```
>
> In the root context, `this` is equal to the global object, and by creating a local `exports` variable you're making it really obvious to anyone reading your code exactly which global variables a script is creating. 



## Functions

`->`. Functions can be one liners or indented on multiple lines.

The last expression in the function is implicitly returned. In other words, you don't need to use the `return` statement unless you want to return earlier inside the function.

```coffeescript
func = -> "bar"
```

> the `->` is turned into a `function` statement, and the `"bar"` string is automatically returned.
>
> [compiled JavaScript]
>
> ```javascript
> var func;
> func = function() {
>   return "bar";
> };	
> ```

indent the function body properly version:

```coffeescript
func = ->
  # An extra line
  "bar"
```



## Function arguments

1. pecifying arguments in parentheses before the arrow.

```coffeescript
times = (a, b) -> a * b
```

> [compiled JavaScript]
>
> ```javascript
> var times;
> times = function(a, b) {
>   return a * b;
> };
> ```

2. default arguments

```coffeescript
times = (a = 1, b = 2) -> a * b
```

>[compiled JavaScript]
>
>```javascript
> var times;
> times = function(a, b) {
>   if (a == null) {
>     a = 1;
>   }
>   if (b == null) {
>     b = 2;
>   }
>   return a * b;
> };
>```

3. use splats to accept multiple arguments, denoted by `...`

```coffeescript
sum = (nums...) -> 
  result = 0
  nums.forEach (n) -> result += n
  result
```

> [compiled JavaScript]
>
> ```javascript
> var sum;
> var __slice = Array.prototype.slice;
> sum = function() {
>   var nums, result;
>   nums = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
>   result = 0;
>   nums.forEach(function(n) {
>     return result += n;
>   });
>   return result;
> };
> ```
> In the example above, `nums` is an array of all the arguments passed to the function. It's not an `arguments` object, but rather a real array, so you don't need to concern yourself with `Array.prototype.splice` or `jQuery.makeArray()` if you want to manipulate it.

```coffeescript
trigger = (events...) ->
  events.splice(1, 0, this)
  this.constructor.trigger.apply(events)
```

> [compiled JavaScript]
>
> ```javascript
> var trigger;
> var __slice = Array.prototype.slice;
> trigger = function() {
>   var events;
>   events = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
>   events.splice(1, 0, this);
>   return this.constructor.trigger.apply(events);
> };
> ```



## Function invocation















