# Modules

Each file is a module, and modules import other modules to use the names they define. Modules might also correspond to extensions coded in external languages such as C, Java, or C#, and even to directories in package imports. Modules are processed with two statements and one important function:

**import**

>  Lets a client (importer) fetch a module as a whole 

**from**

> Allows clients to fetch particular names from a module 

**imp.reload (reload in 2.X)**

> Provides a way to reload a module’s code without stopping Python



## Why Use Modules?

- **Code reuse**

  modules let you save code in files permanently. code in module files is persistent—it can be reloaded and rerun as many times as needed. Just as importantly, modules are a place to define names, known as attributes, which may be referenced by multiple external clients. When used well, this supports a modular program design that groups functionality into reusable units.


- **System namespace partitioning**

  Modules are also the highest-level program organization unit in Python. Although they are fundamentally just packages of names, these packages are also self-contained. Much like the local scopes of functions, this helps avoid name clashes across your programs.

- **Implementing shared services or data**

  From an operational perspective, modules are also useful for implementing components that are shared across a system and hence require only a single copy.



## Python Program Architecture

### How to Structure a Program

program consists of text files containing Python statements, with one main top-level file, and zero or more supplemental files known as modules.

Here’s how this works. The top-level (a.k.a. script) file contains the main flow of control of your program—this is the file you run to launch your application. The module files are libraries of tools used to collect components used by the top-level file, and possibly elsewhere. Top-level files use tools defined in module files, and modules use tools defined in other modules.

Although they are files of code too, module files generally don’t do anything when run directly; rather, they define tools intended for use in other files. A file imports a module to gain access to the tools it defines, which are known as its attributes—variable names attached to objects such as functions. Ultimately, we import modules and access their attributes to use their tools.

### How Imports Work

in Python, imports are not just textual insertions of one file into another. They are really runtime operations that perform three distinct steps the first time a program imports a given file:

1. Find the module’s file.
2. Compile it to byte code (if needed).
3. Run the module’s code to build the objects it defines.

all three of these steps are carried out only the first time a module is imported during a program’s execution; later imports of the same module in a program run bypass all of these steps and simply fetch the already loaded module object in memory.Technically, Python does this by storing loaded modules in a table named `sys.modules` and checking there at the start of an import operation. If the module is not present, a three-step process begins.

#### 1. Find the module’s file.

Python must locate the module file referenced by an import statement. 

#### 2. Compile it to byte code (if needed).

After finding a source code file that matches an import statement by traversing the module search path, Python next compiles it to byte code, During an import operation Python checks both file modification times and the byte code’s Python version number to decide how to proceed. The former uses file “timestamps,” and the latter uses either a “magic” number embedded in the byte code or a filename, depending on the Python release being used. This step chooses an action as follows:

- **Compile**

  If the byte code file is older than the source file (i.e., if you’ve changed the source) or was created by a different Python version, Python automatically regenerates the byte code when the program is run.

  As discussed ahead, this model is modified somewhat in Python 3.2 and later—byte code files are segregated in a `__pycache__` subdirectory and named with their Python version to avoid contention and recompiles when multiple Pythons are installed. This obviates the need to check version numbers in the byte code, but the timestamp check is still used to detect changes in the source.


- **Don’t compile**

  If, on the other hand, Python finds a .pyc byte code file that is not older than the corresponding .py source file and was created by the same Python version, it skips the source-to-byte-code compile step.

  In addition, if Python finds only a byte code file on the search path and no source, it simply loads the byte code directly; this means you can ship a program as just byte code files and avoid sending source. In other words, the compile step is by-passed if possible to speed program startup.

compilation happens when a file is being imported. The byte code of top-level files is used internally and discarded; byte code of imported files is saved in files to speed future imports.

#### 3. Run the module’s code to build the objects it defines.

The final step of an import operation executes the byte code of the module. All statements in the file are run in turn, from top to bottom, and any assignments made to names during this step generate attributes of the resulting module object.



## Byte Code Files: `__pycache__` in Python 3.2+

- **In Python 3.1 and earlier (including all of Python 2.X)** 

  Byte code is stored in files in the same directory as the corresponding source files, normally with the filename extension .pyc (e.g., module.pyc). Byte code files are also stamped internally with the version of Python that created them (known as a “magic” field to developers) so Python knows to recompile when this differs in the version of Python running your program. For instance, if you upgrade to a new Python whose byte code differs, all your byte code files will be recompiled automatically due to a version number mismatch, even if you haven’t changed your source code.


- **In Python 3.2 and later** 

  Byte code is instead stored in files in a subdirectory named `__pycache__`, which Python creates if needed, and which is located in the directory containing the corresponding source files. This helps avoid clutter in your source directories by segregating the byte code files in their own directory. In addition, although byte code files still get the .pyc extension as before, they are given more descriptive names that include text identifying the version of Python that created them (e.g., mod-ule.cpython-32.pyc). This avoids contention and recompiles: because each version of Python installed can have its own uniquely named version of byte code files in the `__pycache__` subdirectory, running under a given version doesn’t overwrite the byte code of another, and doesn’t require recompiles. Technically, byte code filenames also include the name of the Python that created them, so CPython, Jython, and other implementations mentioned in the preface and  can coexist on the same machine without stepping on each other’s work (once they support this model).

In both models, Python always recreates the byte code file if you’ve changed the source code file since the last compile,

#### Byte Code File Models in Action

#### ...



## The Module Search Path / 模块搜索路径

1. The home directory of the program
2. PYTHONPATH directories (if set)
3. Standard library directories
4. The contents of any .pth files (if present)
5. The site-packages home of third-party extensions

- **1. Home directory (automatic)**

  Python first looks for the imported file in the home directory. The meaning of this entry depends on how you are running the code. When you’re running a pro-gram, this entry is the directory containing your program’s top-level script file. When you’re working interactively, this entry is the directory in which you are working (i.e., the current working directory).

  Because this directory is always searched first, if a program is located entirely in a single directory, all of its imports will work automatically with no path configuration required. On the other hand, because this directory is searched first, its files will also override modules of the same name in directories elsewhere on the path; be careful not to accidentally hide library modules this way if you need them in your program, or use package tools we’ll meet later that can partially sidestep this issue.


- **2. PYTHONPATH directories (configurable)**

  Next, Python searches all directories listed in your PYTHONPATH environment variable setting, from left to right (assuming you have set this at all: it’s not preset for you). In brief, PYTHONPATH is simply a list of user-defined and platform-specific names of directories that contain Python code files. You can add all the directories from which you wish to be able to import, and Python will extend the module search path to include all the directories your PYTHONPATH lists.

  Because Python searches the home directory first, this setting is only important when importing files across directory boundaries—that is, if you need to import a file that is stored in a different directory from the file that imports it. You’ll probably want to set your PYTHONPATH variable once you start writing substantial programs, but when you’re first starting out, as long as you save all your module files in the directory in which you’re working (i.e., the home directory, like the C:\code used in this book) your imports will work without you needing to worry about this setting at all.

- **3. Standard library directories (automatic)**

  Next, Python automatically searches the directories where the standard library modules are installed on your machine. Because these are always searched, they normally do not need to be added to your PYTHONPATH or included in path files (discussed next).

- **4      .pth path file directories (configurable)**

  Next, a lesser-used feature of Python allows users to add directories to the module search path by simply listing them, one per line, in a text file whose name ends with a .pth suffix (for “path”). These path configuration files are a somewhat advanced installation-related feature; we won’t cover them fully here, but they provide an alternative to PYTHONPATH settings.



### The sys.path List

If you want to see how the module search path is truly configured on your machine, you can always inspect the path as Python knows it by printing the built-in `sys.path` list (that is, the path attribute of the standard library module sys). This list of directory name strings is the actual search path within Python; on imports, Python searches each directory in this list from left to right, and uses the first file match it finds.

Really, `sys.path` is the module search path. Python configures it at program startup, automatically merging the home directory of the top-level file (or an empty string to designate the current working directory), any PYTHONPATH directories, the contents of any .pth file paths you’ve created, and all the standard library directories. The result is a list of directory name strings that Python searches on each import of a new file.

```
>>> import sys
>>> sys.path 
['', 'C:\\code', 'C:\\Windows\\system32\\python33.zip', 'C:\\Python33\\DLLs', 'C:\\Python33\\lib', 'C:\\Python33', 'C:\\Users\\mark', 'C:\\Python33\\lib\\site-packages']
```



### Module File Selection

filename extensions (e.g., .py) are omitted from import statements intentionally.

#### Module sources

For example, an `import` statement of the form `import b` might today load or resolve to:

- A source code file named b.py


- A byte code file named b.pyc



- An optimized byte code file named b.pyo (a less common format)



- A directory named b, for package imports 



- A compiled extension module, coded in C, C++, or another language, and dynamically linked when imported (e.g., b.so on Linux, or b.dll or b.pyd on Cygwin and Windows)



- A compiled built-in module coded in C and statically linked into Python



- A ZIP file component that is automatically extracted when imported



- An in-memory image, for frozen executables



- A Java class, in the Jython version of Python



- A .NET component, in the IronPython version of Python



# Module Coding Basics

When a module is imported, Python maps the internal module name to an external filename by adding a directory path from the module search path to the front, and a .py or other extension at the end. For instance, a module named M ultimately maps to some external file `<directory>\M.<extension>` that contains the module’s code.



### Module Usage

Clients can use the simple module file we just wrote by running an import or from statement. Both statements find, compile, and run a module file’s code, if it hasn’t yet been loaded. The chief difference is that `import` fetches the module as a whole, so you must qualify to fetch its names; in contrast, `from` fetches (or copies) specific names out of the module.

#### The import Statement

it identifies an external file to be loaded, and it becomes a variable in the script, which references the module object after the file is loaded:

```
>>> import module1							# Get module as a whole (one or more)
>>> module1.printer('Hello world!') 		# Qualify to get names
Hello world!
```

Because it gives a name that refers to the whole module object, we must go through the module name to fetch its attributes (e.g., module1.printer).

#### The from Statement

because from copies specific names from one file over to another scope, it allows us to use the copied names directly in the script without going through the module (e.g., `printer`):

```
>>> from module1 import printer			# Copy out a variable (one or more)
>>> printer('Hello world!') 			# No need to qualify name
Hello world!
```

#### The from * Statement

a special form of from: when we use a * instead of specific names, we get copies of all names assigned at the top level of the referenced module. 

Here again, we can then use the copied name `printer` in our script without going through the module name:

```
>>> from module1 import *				# Copy out _all_ variables
>>> printer('Hello world!') 
Hello world!
```

#### Imports Happen Only Once

**Modules are loaded and run on the first `import` or `from`, and only the first.** This is on purpose—because importing is an expensive operation, by default Python does it just once per file, per process. Later import operations simply fetch the already loaded module object.

**Example :**

```
print('hello')
spam = 1				# Initialize variable

% python
>>> import simple 		# First import: loads and runs file's code
hello
>>> simple.spam 		# Assignment makes an attribute
1

>>> simple.spam = 2		# Change attribute in module
>>> import simple		# Just fetches already loaded module
>>> simple.spam 		# Code wasn't rerun: attribute unchanged
2
```



#### import and from Are Assignments

Just like `def`, `import` and `from` are executable statements, not compile-time declarations. They may be nested in `if` tests, to select among options; appear in function `def`s, to be loaded only on calls (subject to the preceding note); be used in `try` statements, to provide defaults; and so on. They are not resolved or run until Python reaches them while executing your program. In other words, imported modules and names are not available until their associated import or from statements run.

like `def`, the `import` and `from` are implicit assignments:

- **import** assigns an entire module object to a single name.


- **from** assigns one or more names to objects of the same names in another module.

**Example :**

```
small.py:
x = 1 
y = [1, 2]

% python
>>> from small import x, y		# Copy two names out
>>> x = 42						# Changes local x only 
>>> y[0] = 42					# Changes shared mutable in place
```

`x` is not a shared mutable object, but `y` is.

```
>>> import small				# Get module name (from doesn't)
>>> small.x 					# Small's x is not my x
1
>>> small.y 					# But we share a changed mutable
[42, 2]
```