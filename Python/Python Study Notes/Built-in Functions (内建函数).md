# Python Study Notes



# Built-in Functions (内建函数)

Reference:

https://docs.python.org/3.6/library/functions.html

https://docs.python.org/2.7/library/functions.html

Built-in Functions 3.X

| Built-in Functions                       | 3.X                                      |                                          |                                          |                                          |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| [`abs()`](https://docs.python.org/3.6/library/functions.html#abs) | [`dict()`](https://docs.python.org/3.6/library/functions.html#func-dict) | [`help()`](https://docs.python.org/3.6/library/functions.html#help) | [`min()`](https://docs.python.org/3.6/library/functions.html#min) | [`setattr()`](https://docs.python.org/3.6/library/functions.html#setattr) |
| [`all()`](https://docs.python.org/3.6/library/functions.html#all) | [`dir()`](https://docs.python.org/3.6/library/functions.html#dir) | [`hex()`](https://docs.python.org/3.6/library/functions.html#hex) | [`next()`](https://docs.python.org/3.6/library/functions.html#next) | [`slice()`](https://docs.python.org/3.6/library/functions.html#slice) |
| [`any()`](https://docs.python.org/3.6/library/functions.html#any) | [`divmod()`](https://docs.python.org/3.6/library/functions.html#divmod) | [`id()`](https://docs.python.org/3.6/library/functions.html#id) | [`object()`](https://docs.python.org/3.6/library/functions.html#object) | [`sorted()`](https://docs.python.org/3.6/library/functions.html#sorted) |
| [`ascii()`](https://docs.python.org/3.6/library/functions.html#ascii) | [`enumerate()`](https://docs.python.org/3.6/library/functions.html#enumerate) | [`input()`](https://docs.python.org/3.6/library/functions.html#input) | [`oct()`](https://docs.python.org/3.6/library/functions.html#oct) | [`staticmethod()`](https://docs.python.org/3.6/library/functions.html#staticmethod) |
| [`bin()`](https://docs.python.org/3.6/library/functions.html#bin) | [`eval()`](https://docs.python.org/3.6/library/functions.html#eval) | [`int()`](https://docs.python.org/3.6/library/functions.html#int) | [`open()`](https://docs.python.org/3.6/library/functions.html#open) | [`str()`](https://docs.python.org/3.6/library/functions.html#func-str) |
| [`bool()`](https://docs.python.org/3.6/library/functions.html#bool) | [`exec()`](https://docs.python.org/3.6/library/functions.html#exec) | [`isinstance()`](https://docs.python.org/3.6/library/functions.html#isinstance) | [`ord()`](https://docs.python.org/3.6/library/functions.html#ord) | [`sum()`](https://docs.python.org/3.6/library/functions.html#sum) |
| [`bytearray()`](https://docs.python.org/3.6/library/functions.html#bytearray) | [`filter()`](https://docs.python.org/3.6/library/functions.html#filter) | [`issubclass()`](https://docs.python.org/3.6/library/functions.html#issubclass) | [`pow()`](https://docs.python.org/3.6/library/functions.html#pow) | [`super()`](https://docs.python.org/3.6/library/functions.html#super) |
| [`bytes()`](https://docs.python.org/3.6/library/functions.html#bytes) | [`float()`](https://docs.python.org/3.6/library/functions.html#float) | [`iter()`](https://docs.python.org/3.6/library/functions.html#iter) | [`print()`](https://docs.python.org/3.6/library/functions.html#print) | [`tuple()`](https://docs.python.org/3.6/library/functions.html#func-tuple) |
| [`callable()`](https://docs.python.org/3.6/library/functions.html#callable) | [`format()`](https://docs.python.org/3.6/library/functions.html#format) | [`len()`](https://docs.python.org/3.6/library/functions.html#len) | [`property()`](https://docs.python.org/3.6/library/functions.html#property) | [`type()`](https://docs.python.org/3.6/library/functions.html#type) |
| [`chr()`](https://docs.python.org/3.6/library/functions.html#chr) | [`frozenset()`](https://docs.python.org/3.6/library/functions.html#func-frozenset) | [`list()`](https://docs.python.org/3.6/library/functions.html#func-list) | [`range()`](https://docs.python.org/3.6/library/functions.html#func-range) | [`vars()`](https://docs.python.org/3.6/library/functions.html#vars) |
| [`classmethod()`](https://docs.python.org/3.6/library/functions.html#classmethod) | [`getattr()`](https://docs.python.org/3.6/library/functions.html#getattr) | [`locals()`](https://docs.python.org/3.6/library/functions.html#locals) | [`repr()`](https://docs.python.org/3.6/library/functions.html#repr) | [`zip()`](https://docs.python.org/3.6/library/functions.html#zip) |
| [`compile()`](https://docs.python.org/3.6/library/functions.html#compile) | [`globals()`](https://docs.python.org/3.6/library/functions.html#globals) | [`map()`](https://docs.python.org/3.6/library/functions.html#map) | [`reversed()`](https://docs.python.org/3.6/library/functions.html#reversed) | [`__import__()`](https://docs.python.org/3.6/library/functions.html#__import__) |
| [`complex()`](https://docs.python.org/3.6/library/functions.html#complex) | [`hasattr()`](https://docs.python.org/3.6/library/functions.html#hasattr) | [`max()`](https://docs.python.org/3.6/library/functions.html#max) | [`round()`](https://docs.python.org/3.6/library/functions.html#round) |                                          |
| [`delattr()`](https://docs.python.org/3.6/library/functions.html#delattr) | [`hash()`](https://docs.python.org/3.6/library/functions.html#hash) | [`memoryview()`](https://docs.python.org/3.6/library/functions.html#func-memoryview) | [`set()`](https://docs.python.org/3.6/library/functions.html#func-set) |                                          |



Built-in Functions 2.X

| Built-in Functions                       | 2.X                                      |                                          |                                          |                                          |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| [`abs()`](https://docs.python.org/2.7/library/functions.html#abs) | [`divmod()`](https://docs.python.org/2.7/library/functions.html#divmod) | [`input()`](https://docs.python.org/2.7/library/functions.html#input) | [`open()`](https://docs.python.org/2.7/library/functions.html#open) | [`staticmethod()`](https://docs.python.org/2.7/library/functions.html#staticmethod) |
| [`all()`](https://docs.python.org/2.7/library/functions.html#all) | [`enumerate()`](https://docs.python.org/2.7/library/functions.html#enumerate) | [`int()`](https://docs.python.org/2.7/library/functions.html#int) | [`ord()`](https://docs.python.org/2.7/library/functions.html#ord) | [`str()`](https://docs.python.org/2.7/library/functions.html#str) |
| [`any()`](https://docs.python.org/2.7/library/functions.html#any) | [`eval()`](https://docs.python.org/2.7/library/functions.html#eval) | [`isinstance()`](https://docs.python.org/2.7/library/functions.html#isinstance) | [`pow()`](https://docs.python.org/2.7/library/functions.html#pow) | [`sum()`](https://docs.python.org/2.7/library/functions.html#sum) |
| [`basestring()`](https://docs.python.org/2.7/library/functions.html#basestring) | [`execfile()`](https://docs.python.org/2.7/library/functions.html#execfile) | [`issubclass()`](https://docs.python.org/2.7/library/functions.html#issubclass) | [`print()`](https://docs.python.org/2.7/library/functions.html#print) | [`super()`](https://docs.python.org/2.7/library/functions.html#super) |
| [`bin()`](https://docs.python.org/2.7/library/functions.html#bin) | [`file()`](https://docs.python.org/2.7/library/functions.html#file) | [`iter()`](https://docs.python.org/2.7/library/functions.html#iter) | [`property()`](https://docs.python.org/2.7/library/functions.html#property) | [`tuple()`](https://docs.python.org/2.7/library/functions.html#tuple) |
| [`bool()`](https://docs.python.org/2.7/library/functions.html#bool) | [`filter()`](https://docs.python.org/2.7/library/functions.html#filter) | [`len()`](https://docs.python.org/2.7/library/functions.html#len) | [`range()`](https://docs.python.org/2.7/library/functions.html#range) | [`type()`](https://docs.python.org/2.7/library/functions.html#type) |
| [`bytearray()`](https://docs.python.org/2.7/library/functions.html#bytearray) | [`float()`](https://docs.python.org/2.7/library/functions.html#float) | [`list()`](https://docs.python.org/2.7/library/functions.html#list) | [`raw_input()`](https://docs.python.org/2.7/library/functions.html#raw_input) | [`unichr()`](https://docs.python.org/2.7/library/functions.html#unichr) |
| [`callable()`](https://docs.python.org/2.7/library/functions.html#callable) | [`format()`](https://docs.python.org/2.7/library/functions.html#format) | [`locals()`](https://docs.python.org/2.7/library/functions.html#locals) | [`reduce()`](https://docs.python.org/2.7/library/functions.html#reduce) | [`unicode()`](https://docs.python.org/2.7/library/functions.html#unicode) |
| [`chr()`](https://docs.python.org/2.7/library/functions.html#chr) | [`frozenset()`](https://docs.python.org/2.7/library/functions.html#func-frozenset) | [`long()`](https://docs.python.org/2.7/library/functions.html#long) | [`reload()`](https://docs.python.org/2.7/library/functions.html#reload) | [`vars()`](https://docs.python.org/2.7/library/functions.html#vars) |
| [`classmethod()`](https://docs.python.org/2.7/library/functions.html#classmethod) | [`getattr()`](https://docs.python.org/2.7/library/functions.html#getattr) | [`map()`](https://docs.python.org/2.7/library/functions.html#map) | [`repr()`](https://docs.python.org/2.7/library/functions.html#func-repr) | [`xrange()`](https://docs.python.org/2.7/library/functions.html#xrange) |
| [`cmp()`](https://docs.python.org/2.7/library/functions.html#cmp) | [`globals()`](https://docs.python.org/2.7/library/functions.html#globals) | [`max()`](https://docs.python.org/2.7/library/functions.html#max) | [`reversed()`](https://docs.python.org/2.7/library/functions.html#reversed) | [`zip()`](https://docs.python.org/2.7/library/functions.html#zip) |
| [`compile()`](https://docs.python.org/2.7/library/functions.html#compile) | [`hasattr()`](https://docs.python.org/2.7/library/functions.html#hasattr) | [`memoryview()`](https://docs.python.org/2.7/library/functions.html#func-memoryview) | [`round()`](https://docs.python.org/2.7/library/functions.html#round) | [`__import__()`](https://docs.python.org/2.7/library/functions.html#__import__) |
| [`complex()`](https://docs.python.org/2.7/library/functions.html#complex) | [`hash()`](https://docs.python.org/2.7/library/functions.html#hash) | [`min()`](https://docs.python.org/2.7/library/functions.html#min) | [`set()`](https://docs.python.org/2.7/library/functions.html#func-set) |                                          |
| [`delattr()`](https://docs.python.org/2.7/library/functions.html#delattr) | [`help()`](https://docs.python.org/2.7/library/functions.html#help) | [`next()`](https://docs.python.org/2.7/library/functions.html#next) | [`setattr()`](https://docs.python.org/2.7/library/functions.html#setattr) |                                          |
| [`dict()`](https://docs.python.org/2.7/library/functions.html#func-dict) | [`hex()`](https://docs.python.org/2.7/library/functions.html#hex) | [`object()`](https://docs.python.org/2.7/library/functions.html#object) | [`slice()`](https://docs.python.org/2.7/library/functions.html#slice) |                                          |
| [`dir()`](https://docs.python.org/2.7/library/functions.html#dir) | [`id()`](https://docs.python.org/2.7/library/functions.html#id) | [`oct()`](https://docs.python.org/2.7/library/functions.html#oct) | [`sorted()`](https://docs.python.org/2.7/library/functions.html#sorted) |                                          |



## bin()

**bin()** 返回一个整数 int 或者长整数 long int 的二进制表示。

> ```
> bin(...)
>     bin(number) -> string
>     
>     Return the binary representation of an integer.
>     
>        >>> bin(2796202)
>        '0b1010101010101010101010'
> ```

#### 函数语法

```
bin(x)
```

#### 参数

- x -- int 或者 long int 数字

#### 返回值

字符串。

#### 实例

```
>>> bin(10)
'0b1010'
>>> bin(20)
'0b10100'
```









## dir()

**dir()** 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法 `__dir__()` ，该方法将被调用。如果参数不包含 `__dir__()` ，该方法将最大限度地收集参数信息。

> ```
> dir(...)
>     dir([object]) -> list of strings
>     
>     If called without an argument, return the names in the current scope.
>     Else, return an alphabetized list of names comprising (some of) the attributes
>     of the given object, and of attributes reachable from it.
>     If the object supplies a method named __dir__, it will be used; otherwise
>     the default dir() logic is used and returns:
>       for a module object: the module's attributes.
>       for a class object:  its attributes, and recursively the attributes
>         of its bases.
>       for any other object: its attributes, its class's attributes, and
>         recursively the attributes of its class's base classes.
> ```

#### 函数语法

```
dir([object])
```

#### 参数

- object -- 对象、变量、类型。

#### 返回值

返回模块的属性列表。

#### 扩展

To find out what attributes are provided in objects of built-in types, run `dir` on a literal or an existing instance of the desired type.

For example, to see list and string attributes, you can pass empty objects:

```
>>> dir([]) ['__add__', '__class__', '__contains__', ...more..., 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

>>> dir('') ['__add__', '__class__', '__contains__', ...more..., 'split', 'splitlines', 'startswith','strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
```

#### 实例

```
>>>dir()   		# 获得当前模块的属性列表
['__builtins__', '__doc__', '__name__', '__package__', 'arr', 'myslice']
>>> dir([ ])    # 查看列表的方法
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
```









## enumerate()

enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。

Python 2.3. 以上版本可用，2.6 添加 start 参数。

> ```
> class enumerate(object)
>  |  enumerate(iterable[, start]) -> iterator for index, value of iterable
>  |  
>  |  Return an enumerate object.  iterable must be another object that supports
>  |  iteration.  The enumerate object yields pairs containing a count (from
>  |  start, which defaults to zero) and a value yielded by the iterable argument.
>  |  enumerate is useful for obtaining an indexed list:
>  |      (0, seq[0]), (1, seq[1]), (2, seq[2]), ...
>  |  
>  |  Methods defined here:
>  |  
>  |  __getattribute__(self, name, /)
>  |      Return getattr(self, name).
>  |  
>  |  __iter__(self, /)
>  |      Implement iter(self).
>  |  
>  |  __new__(*args, **kwargs) from builtins.type
>  |      Create and return a new object.  See help(type) for accurate signature.
>  |  
>  |  __next__(self, /)
>  |      Implement next(self).
>  |  
>  |  __reduce__(...)
>  |      Return state information for pickling.
> ```

#### 函数语法

```
enumerate(sequence, [start=0])
```

#### 参数

- sequence -- 一个序列、迭代器或其他支持迭代对象。
- start -- 下标起始位置。

#### 返回值

返回 enumerate(枚举) 对象。

#### 实例

```
>>>seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))       			# 小标从 1 开始
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

普通的 `for` 循环:

```
>>>i = 0
>>> seq = ['one', 'two', 'three']
>>> for element in seq:
...     print (i, seq[i])
...     i +=1
... 
0 one
1 two
2 three
```

`for` 循环使用 `enumerate`:

```
>>> seq = ['one', 'two', 'three']
>>> for i, item in enumerate(seq):
...     print(i, item)
... 
0 one
1 two
2 three
```

it has a method called by the `next` built-in function, which returns an (index, value) tuple each time through the loop. The `for` steps through these tuples automatically, which allows us to unpack their values with tuple assignment,

```
>>> seq = ['one', 'two', 'three']
>>> E = enumerate(seq)
>>> E
<enumerate object at 0x101605f78>
>>> next(E)
(0, 'one')
>>> next(E)
(1, 'two')
>>> next(E)
(2, 'three')
```





## eval()

eval() 函数用来执行一个字符串表达式，并返回表达式的值。

> ```
> eval(...)
>     eval(source[, globals[, locals]]) -> value
>     
>     Evaluate the source in the context of globals and locals.
>     The source may be a string representing a Python expression
>     or a code object as returned by compile().
>     The globals must be a dictionary and locals can be any mapping,
>     defaulting to the current globals and locals.
>     If only globals is given, locals defaults to it.
> ```

#### 函数语法

```
eval(expression[, globals[, locals]])
```

#### 参数

- expression -- 表达式。
- globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。
- locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。

#### 返回值

返回表达式计算结果

#### 实例

```
>>>x = 7
>>> eval( '3 * x' )
21
>>> eval('pow(2,2)')
4
>>> eval('2 + 2')
4
>>> eval("n + 4")
85
```





## filter()

**filter()** 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。

该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。

> ```
> class filter(object)
>  |  filter(function or None, iterable) --> filter object
>  |  
>  |  Return an iterator yielding those items of iterable for which function(item)
>  |  is true. If function is None, return the items that are true.
>  |  
>  |  Methods defined here:
>  |  
>  |  __getattribute__(self, name, /)
>  |      Return getattr(self, name).
>  |  
>  |  __iter__(self, /)
>  |      Implement iter(self).
>  |  
>  |  __new__(*args, **kwargs) from builtins.type
>  |      Create and return a new object.  See help(type) for accurate signature.
>  |  
>  |  __next__(self, /)
>  |      Implement next(self).
>  |  
>  |  __reduce__(...)
>  |      Return state information for pickling.
> ```

#### 函数语法:

```
filter(function, iterable)
```

#### 参数说明：

- function -- 判断函数。
- iterable -- 可迭代对象

#### 返回值:

返回列表。

#### 扩展：

`filter` both accepts an iterable to process and returns an iterable to generate results in 3.X.

It returns items in an iterable for which a passed-in function returns `True` (as we’ve learned, in Python `True` includes nonempty objects, and `bool` returns an object’s truth value)

```
>>> filter(bool, ['spam', '', 'ni']) 
<filter object at 0x00000000029B7B70>
>>> list(filter(bool, ['spam', '', 'ni'])) 
['spam', 'ni']
```

It can also generally be emulated by extended list comprehension syntax that automatically tests truth values:

```
>>> [x for x in ['spam', '', 'ni'] if bool(x)] 
['spam', 'ni']
>>> [x for x in ['spam', '', 'ni'] if x] 
['spam', 'ni']
```

#### 实例:

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
def is_odd(n):
    return n % 2 == 1
 
newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
print(newlist)			# the result is:[1, 3, 5, 7, 9]
```

```
[1, 3, 5, 7, 9]
```





## help()

**help()** 函数用于查看函数或模块用途的详细说明。

> ```
> class _Helper(builtins.object)
>  |  Define the builtin 'help'.
>  |  
>  |  This is a wrapper around pydoc.help that provides a helpful message
>  |  when 'help' is typed at the Python interactive prompt.
>  |  
>  |  Calling help() at the Python prompt starts an interactive help session.
>  |  Calling help(thing) prints help for the python object 'thing'.
>  |  
>  |  Methods defined here:
>  |  
>  |  __call__(self, *args, **kwds)
>  |  
>  |  __repr__(self)
>  |  
>  |  ----------------------------------------------------------------------
>  |  Data descriptors defined here:
>  |  
>  |  __dict__
>  |      dictionary for instance variables (if defined)
>  |  
>  |  __weakref__
>  |      list of weak references to the object (if defined)
> ```

#### 函数语法:

```
help([object])
```

#### 参数说明：

- object -- 对象；

#### 返回值:

返回对象帮助信息。

#### 实例:

```
>>>help('sys')             # 查看 sys 模块的帮助
……显示帮助信息……
 
>>>help('str')             # 查看 str 数据类型的帮助
……显示帮助信息……
 
>>>a = [1,2,3]
>>>help(a)                 # 查看列表 list 帮助信息
……显示帮助信息……
 
>>>help(a.append)          # 显示list的append方法的帮助
……显示帮助信息……
```



## int()

int() 函数用于将一个字符串会数字转换为整型。

> ```
> class int(object)
>  |  int(x=0) -> integer
>  |  int(x, base=10) -> integer
>  |  
>  |  Convert a number or string to an integer, or return 0 if no arguments
>  |  are given.  If x is a number, return x.__int__().  For floating point
>  |  numbers, this truncates towards zero.
>  |  
>  |  If x is not a number or if base is given, then x must be a string,
>  |  bytes, or bytearray instance representing an integer literal in the
>  |  given base.  The literal can be preceded by '+' or '-' and be surrounded
>  |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
>  |  Base 0 means to interpret the base from the string as an integer literal.
>  |  >>> int('0b100', base=0)
>  |  4
>  |  
>  |  Methods defined here:
>  |  
>  |  __abs__(self, /)
>  |      abs(self)
>  |  
>  |  __add__(self, value, /)
>  |      Return self+value.
>  |  
>  |  __and__(self, value, /)
>  |      Return self&value.
>  |  
>  |  __bool__(self, /)
>  |      self != 0
>  |  
>  |  __ceil__(...)
>  |      Ceiling of an Integral returns itself.
>  |  
>  |  __divmod__(self, value, /)
>  |      Return divmod(self, value).
>  |  
>  |  __eq__(self, value, /)
>  |      Return self==value.
>  |  
>  |  __float__(self, /)
>  |      float(self)
>  |  
>  |  __floor__(...)
>  |      Flooring an Integral returns itself.
>  |  
>  |  __floordiv__(self, value, /)
>  |      Return self//value.
>  |  
>  |  __format__(...)
>  |  
>  |  __ge__(self, value, /)
>  |      Return self>=value.
>  |  
>  |  __getattribute__(self, name, /)
>  |      Return getattr(self, name).
>  |  
>  |  __getnewargs__(...)
>  |  
>  |  __gt__(self, value, /)
>  |      Return self>value.
>  |  
>  |  __hash__(self, /)
>  |      Return hash(self).
>   |  
>  |  __index__(self, /)
>  |      Return self converted to an integer, if self is suitable for use as an index into a list.
>  |  
>  |  __int__(self, /)
>  |      int(self)
>  |  
>  |  __invert__(self, /)
>  |      ~self
>  |  
>  |  __le__(self, value, /)
>  |      Return self<=value.
>  |  
>  |  __lshift__(self, value, /)
>  |      Return self<<value.
>  |  
>  |  __lt__(self, value, /)
>  |      Return self<value.
>  |  
>  |  __mod__(self, value, /)
>  |      Return self%value.
>  |  
>  |  __mul__(self, value, /)
>  |      Return self*value.
>  |  
>  |  __ne__(self, value, /)
>  |      Return self!=value.
>  |  
>  |  __neg__(self, /)
>  |      -self
>  |  
>  |  __new__(*args, **kwargs) from builtins.type
>  |      Create and return a new object.  See help(type) for accurate signature.
>  |  
>  |  __or__(self, value, /)
>  |      Return self|value.
>  |  
>  |  __pos__(self, /)
>  |      +self
>  |  
>  |  __pow__(self, value, mod=None, /)
>  |      Return pow(self, value, mod).
>  |  
>  |  __radd__(self, value, /)
>  |      Return value+self.
>  |  
>  |  __rand__(self, value, /)
>  |      Return value&self.
>  |  
>  |  __rdivmod__(self, value, /)
>  |      Return divmod(value, self).
>  |  
>  |  __repr__(self, /)
>  |      Return repr(self).
>  |  
>  |  __rfloordiv__(self, value, /)
>  |      Return value//self.
>  |  
>  |  __rlshift__(self, value, /)
>  |      Return value<<self.
>  |  
>  |  __rmod__(self, value, /)
>  |      Return value%self.
>  |  
>  |  __rmul__(self, value, /)
>  |      Return value*self.
>  |  
>  |  __ror__(self, value, /)
>  |      Return value|self.
>  |  
>  |  __round__(...)
>  |      Rounding an Integral returns itself.
>  |      Rounding with an ndigits argument also returns an integer.
>  |  
>  |  __rpow__(self, value, mod=None, /)
>  |      Return pow(value, self, mod).
>  |  
>  |  __rrshift__(self, value, /)
>  |      Return value>>self.
>  |  
>  |  __rshift__(self, value, /)
>  |      Return self>>value.
>  |  
>  |  __rsub__(self, value, /)
>  |      Return value-self.
>  |  
>  |  __rtruediv__(self, value, /)
>  |      Return value/self.
>  |  
>  |  __rxor__(self, value, /)
>  |      Return value^self.
>  |  
>  |  __sizeof__(...)
>  |      Returns size in memory, in bytes
>  |  
>  |  __str__(self, /)
>  |      Return str(self).
>  |  
>  |  __sub__(self, value, /)
>  |      Return self-value.
>  |  
>  |  __truediv__(self, value, /)
>  |      Return self/value.
>  |  
>  |  __trunc__(...)
>  |      Truncating an Integral returns itself.
>  |  
>  |  __xor__(self, value, /)
>  |      Return self^value.
>  |  
>  |  bit_length(...)
>  |      int.bit_length() -> int
>  |      
>  |      Number of bits necessary to represent self in binary.
>  |      >>> bin(37)
>  |      '0b100101'
>  |      >>> (37).bit_length()
>  |      6
>  |  
>  |  conjugate(...)
>  |      Returns self, the complex conjugate of any int.
>  |  
>  |  from_bytes(...) from builtins.type
>  |      int.from_bytes(bytes, byteorder, *, signed=False) -> int
>  |      
>  |      Return the integer represented by the given array of bytes.
>  |      
>  |      The bytes argument must either support the buffer protocol or be an
>  |      iterable object producing bytes.  Bytes and bytearray are examples of
>  |      built-in objects that support the buffer protocol.
>  |      
>  |      The byteorder argument determines the byte order used to represent the
>  |      integer.  If byteorder is 'big', the most significant byte is at the
>  |      beginning of the byte array.  If byteorder is 'little', the most
>  |      significant byte is at the end of the byte array.  To request the native
>  |      byte order of the host system, use `sys.byteorder' as the byte order value.
>  |      
>  |      The signed keyword-only argument indicates whether two's complement is
>  |      used to represent the integer.
>  |  
>  |  to_bytes(...)
>  |      int.to_bytes(length, byteorder, *, signed=False) -> bytes
>  |      
>  |      Return an array of bytes representing an integer.
>  |      
>  |      The integer is represented using length bytes.  An OverflowError is
>  |      raised if the integer is not representable with the given number of
>  |      bytes.
>  |      
>  |      The byteorder argument determines the byte order used to represent the
>  |      integer.  If byteorder is 'big', the most significant byte is at the
>  |      beginning of the byte array.  If byteorder is 'little', the most
>  |      significant byte is at the end of the byte array.  To request the native
>  |      byte order of the host system, use `sys.byteorder' as the byte order value.
>  |      
>  |      The signed keyword-only argument determines whether two's complement is
>  |      used to represent the integer.  If signed is False and a negative integer
>  |      is given, an OverflowError is raised.
>  |  
>  |  ----------------------------------------------------------------------
>  |  Data descriptors defined here:
>  |  
>  |  denominator
>  |      the denominator of a rational number in lowest terms
>  |  
>  |  imag
>  |      the imaginary part of a complex number
>  |  
>  |  numerator
>  |      the numerator of a rational number in lowest terms
>  |  
>  |  real
>  |      the real part of a complex number
> ```

#### 函数语法

```
class int(x, base=10)
```

#### 参数

- x -- 字符串或数字。
- base -- 进制数，默认十进制。

#### 返回值

返回整型数据。

#### 实例

```
>>>int()               # 不传入参数时，得到结果0
0
>>> int(3)
3
>>> int(3.6)
3
>>> int('12',16)        # 如果是带参数base的话，12要以字符串的形式进行输入，12 为 16进制
18
>>> int('0xa',16)  
10  
>>> int('10',8)  
8
```





## isinstance() 

isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。

> isinstance() 与 type() 区别：
>
> - type() 不会认为子类是一种父类类型，不考虑继承关系。
> - isinstance() 会认为子类是一种父类类型，考虑继承关系。
>
> 如果要判断两个类型是否相同推荐使用 isinstance()。

> ```
> isinstance(...)
>     isinstance(object, class-or-type-or-tuple) -> bool
>     
>     Return whether an object is an instance of a class or of a subclass thereof.
>     With a type as second argument, return whether that is the object's type.
>     The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for
>     isinstance(x, A) or isinstance(x, B) or ... (etc.).
>
> ```

#### 函数语法:

```
isinstance(object, classinfo)
```

#### 参数说明：

- object -- 实例对象。
- classinfo -- 可以是直接或间接类名、基本类型或者有它们组成的元组。

#### 返回值:

如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。。

#### 实例:

```
>>>a = 2
>>> isinstance (a,int)
True
>>> isinstance (a,str)
False
>>> isinstance (a,(str,int,list))    # 是元组中的一个返回 True
True
```

#### type() 与 isinstance() 区别:

```
class A:
    pass
 
class B(A):
    pass
 
isinstance(A(), A)    # returns True
type(A()) == A        # returns True
isinstance(B(), A)    # returns True
type(B()) == A        # returns False
```



## iter()

**iter()** 函数用来生成迭代器。

> ```
> iter(...)
>     iter(iterable) -> iterator
>     iter(callable, sentinel) -> iterator
>     
>     Get an iterator from an object.  In the first form, the argument must
>     supply its own iterator, or be a sequence.
>     In the second form, the callable is called until it returns the sentinel.
> ```

#### 函数语法:

```
iter(object[, sentinel])
```

#### 参数说明：

- object -- 支持迭代的集合对象。
- sentinel -- 如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如，函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的 `__next__()` 方法时，都会调用 object。

#### 返回值:

迭代器对象。

#### 实例:

```
>>>L = [1, 2, 3]
>>> for i in iter(L):
...     print(i)
... 
1
2
3
```



## map()

**map()** 会根据提供的函数对指定序列做映射。

第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。

> ```
> class map(object)
>  |  map(func, *iterables) --> map object
>  |  
>  |  Make an iterator that computes the function using arguments from
>  |  each of the iterables.  Stops when the shortest iterable is exhausted.
>  |  
>  |  Methods defined here:
>  |  
>  |  __getattribute__(self, name, /)
>  |      Return getattr(self, name).
>  |  
>  |  __iter__(self, /)
>  |      Implement iter(self).
>  |  
>  |  __new__(*args, **kwargs) from builtins.type
>  |      Create and return a new object.  See help(type) for accurate signature.
>  |  
>  |  __next__(self, /)
>  |      Implement next(self).
>  |  
>  |  __reduce__(...)
>  |      Return state information for pickling.
> ```

#### 函数语法:

```
map(function, iterable, ...)
```

#### 参数说明：

- function -- 函数，有两个参数
- iterable -- 一个或多个序列

#### 返回值:

返回列表。

#### 扩展：

- **they are their own iterators—after you step through their results once, they are ex-hausted**. In other words, you can’t have multiple iterators on their results that maintain different positions in those results.
- **a single iterator generally means an object returns itself**

#### 实例:

```
>>>def square(x) :            		 # 计算平方数
...     return x ** 2
... 

>>> map(square, [1,2,3,4,5])   		 # Python 2.X
[1, 4, 9, 16, 25]

>>> map(square, [1,2,3,4])			 # Python 3.X
<map object at 0x1014040b8>		
>>> list(map(square, [1,2,3,4,5]))   # 计算列表和：1+2+3+4+5
[1, 4, 9, 16, 25]

>>> list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
 
# 提供了两个列表，对相同位置的列表数据进行相加
>>> list(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
[3, 7, 11, 15, 19]
```
Python 3.X:
```
>>> M = map(abs, (-1, 0, 1))			# map returns an iterable, not a list
>>> M
<map object at 0x1010d8198>
>>> next(M)								# Use iterator manually: exhausts results
1										# These do not support len() or indexing
>>> next(M)
0
>>> next(M)
1
>>> next(M)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

>>> for x in M: print(x)				# map iterator is now empty: one pass only
... 

>>> M = map(abs, (-1, 0, 1))			# Make a new iterable/iterator to scan again
>>> for x in M: print(x)				# Iteration contexts auto call next()
... 
1
0
1
>>> list(map(abs, (-1, 0, 1)))			# Can force a real list if needed
[1, 0, 1]
```





## next()

**next()** 返回迭代器的下一个项目。

> ```
> next(...)
>     next(iterator[, default])
>     
>     Return the next item from the iterator. If default is given and the iterator
>     is exhausted, it is returned instead of raising StopIteration.
> ```

#### 函数语法:

```
next(iterator[, default])
```

#### 参数说明：

- iterator -- 可迭代对象
- default -- 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。

#### 返回值:

Return the next item from the iterator or raising StopIteration

#### 实例:

example 1:

```
>>> L = 'good'
>>> I = iter(L)
>>> I
<str_iterator object at 0x10113bda0>
>>> list(I)
['g', 'o', 'o', 'd']
```
example 2:

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
        print(x)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
```

> ```
> 1
> 2
> 3
> 4
> 5
> ```



## open()

python open() 函数用于打开一个文件，创建一个 `file` 对象，相关的方法才可以调用它进行读写。

更多文件操作可参考：[Python 文件I/O](http://www.runoob.com/python/python-files-io.html)。

> ```
> open(...)
>     open(file, mode='r', buffering=-1, encoding=None,
>          errors=None, newline=None, closefd=True, opener=None) -> file object
>     
>     Open file and return a stream.  Raise IOError upon failure.
>     
>     file is either a text or byte string giving the name (and the path
>     if the file isn't in the current working directory) of the file to
>     be opened or an integer file descriptor of the file to be
>     wrapped. (If a file descriptor is given, it is closed when the
>     returned I/O object is closed, unless closefd is set to False.)
>     
>     mode is an optional string that specifies the mode in which the file
>     is opened. It defaults to 'r' which means open for reading in text
>     mode.  Other common values are 'w' for writing (truncating the file if
>     it already exists), 'x' for creating and writing to a new file, and
>     'a' for appending (which on some Unix systems, means that all writes
>     append to the end of the file regardless of the current seek position).
>     In text mode, if encoding is not specified the encoding used is platform
>     dependent: locale.getpreferredencoding(False) is called to get the
>     current locale encoding. (For reading and writing raw bytes use binary
>     mode and leave encoding unspecified.) The available modes are:
>     
>     ========= ===============================================================
>     Character Meaning
>     --------- ---------------------------------------------------------------
>     'r'       open for reading (default)
>     'w'       open for writing, truncating the file first
>     'x'       create a new file and open it for writing
>     'a'       open for writing, appending to the end of the file if it exists
>     'b'       binary mode
>     't'       text mode (default)
>     '+'       open a disk file for updating (reading and writing)
>     'U'       universal newline mode (deprecated)
>     ========= ===============================================================
>     
>     The default mode is 'rt' (open for reading text). For binary random
>     access, the mode 'w+b' opens and truncates the file to 0 bytes, while
>     'r+b' opens the file without truncation. The 'x' mode implies 'w' and
>     raises an `FileExistsError` if the file already exists.
>     
>     Python distinguishes between files opened in binary and text modes,
>     even when the underlying operating system doesn't. Files opened in
>     binary mode (appending 'b' to the mode argument) return contents as
>     bytes objects without any decoding. In text mode (the default, or when
>     't' is appended to the mode argument), the contents of the file are
>     returned as strings, the bytes having been first decoded using a
>     platform-dependent encoding or using the specified encoding if given.
>     
>     'U' mode is deprecated and will raise an exception in future versions
>     of Python.  It has no effect in Python 3.  Use newline to control
>     universal newlines mode.
>     
>     buffering is an optional integer used to set the buffering policy.
>     Pass 0 to switch buffering off (only allowed in binary mode), 1 to select
>     line buffering (only usable in text mode), and an integer > 1 to indicate
>     the size of a fixed-size chunk buffer.  When no buffering argument is
>     given, the default buffering policy works as follows:
>     
>     * Binary files are buffered in fixed-size chunks; the size of the buffer
>       is chosen using a heuristic trying to determine the underlying device's
>       "block size" and falling back on `io.DEFAULT_BUFFER_SIZE`.
>       On many systems, the buffer will typically be 4096 or 8192 bytes long.
>     
>     * "Interactive" text files (files for which isatty() returns True)
>       use line buffering.  Other text files use the policy described above
>       for binary files.
>     
>     encoding is the name of the encoding used to decode or encode the
>     file. This should only be used in text mode. The default encoding is
>     platform dependent, but any encoding supported by Python can be
>     passed.  See the codecs module for the list of supported encodings.
>     
>     errors is an optional string that specifies how encoding errors are to
>     be handled---this argument should not be used in binary mode. Pass
>     'strict' to raise a ValueError exception if there is an encoding error
>     (the default of None has the same effect), or pass 'ignore' to ignore
>     errors. (Note that ignoring encoding errors can lead to data loss.)
>     See the documentation for codecs.register or run 'help(codecs.Codec)'
>     for a list of the permitted encoding error strings.
>     
>     newline controls how universal newlines works (it only applies to text
>     mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as
>     follows:
>     
>     * On input, if newline is None, universal newlines mode is
>       enabled. Lines in the input can end in '\n', '\r', or '\r\n', and
>       these are translated into '\n' before being returned to the
>       caller. If it is '', universal newline mode is enabled, but line
>       endings are returned to the caller untranslated. If it has any of
>       the other legal values, input lines are only terminated by the given
>       string, and the line ending is returned to the caller untranslated.
>     
>     * On output, if newline is None, any '\n' characters written are
>       translated to the system default line separator, os.linesep. If
>       newline is '' or '\n', no translation takes place. If newline is any
>       of the other legal values, any '\n' characters written are translated
>       to the given string.
>     
>     If closefd is False, the underlying file descriptor will be kept open
>     when the file is closed. This does not work when a file name is given
>     and must be True in that case.
>     
>     A custom opener can be used by passing a callable as *opener*. The
>     underlying file descriptor for the file object is then obtained by
>     calling *opener* with (*file*, *flags*). *opener* must return an open
>     file descriptor (passing os.open as *opener* results in functionality
>     similar to passing None).
>     
>     open() returns a file object whose type depends on the mode, and
>     through which the standard file operations such as reading and writing
>     are performed. When open() is used to open a file in a text mode ('w',
>     'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open
>     a file in a binary mode, the returned class varies: in read binary
>     mode, it returns a BufferedReader; in write binary and append binary
>     modes, it returns a BufferedWriter, and in read/write mode, it returns
>     a BufferedRandom.
>     
>     It is also possible to use a string or bytearray as a file for both
>     reading and writing. For strings StringIO can be used like a file
>     opened in a text mode, and for bytes a BytesIO can be used like a file
>     opened in a binary mode.
> ```

#### 函数语法:

```
open(name[, mode[, buffering]])
```

#### 参数说明：

- name : 一个包含了你要访问的文件名称的字符串值。
- mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。
- buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。

#### 不同模式打开文件的完全列表：

| 模式   | 描述                                       |
| ---- | ---------------------------------------- |
| r    | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。         |
| rb   | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。   |
| r+   | 打开一个文件用于读写。文件指针将会放在文件的开头。                |
| rb+  | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。          |
| w    | 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| wb   | 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| w+   | 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| wb+  | 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| a    | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| ab   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| a+   | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |
| ab+  | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |

#### file 对象方法

**file.read([size])** size未指定则返回整个文件,如果文件大小>2倍内存则有问题.f.read()读到文件尾时返回""(空字串)

**file.readline()** 返回一行

**file.readline([size]) **返回包含size行的列表,size 未指定则返回全部行

**for line in file: print line **#通过迭代器访问

**file.write("hello\n")** #如果要写入字符串以外的数据,先将他转换为字符串.

**file.tell()** 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).

**file.seek(偏移量,[起始位置])** 用来移动文件指针.

- 偏移量:单位:比特,可正可负
- 起始位置:0-文件头,默认值;1-当前位置;2-文件尾

**file.close()** 关闭文件





## range()

pytho range() 函数可创建一个整数列表，一般用在 for 循环中。

> ```
> class range(object)
>  |  range(stop) -> range object
>  |  range(start, stop[, step]) -> range object
>  |  
>  |  Return a sequence of numbers from start to stop by step.
>  |  
>  |  Methods defined here:
>  |  
>  |  __contains__(self, key, /)
>  |      Return key in self.
>  |  
>  |  __eq__(self, value, /)
>  |      Return self==value.
>  |  
>  |  __ge__(self, value, /)
>  |      Return self>=value.
>  |  
>  |  __getattribute__(self, name, /)
>  |      Return getattr(self, name).
>  |  
>  |  __getitem__(self, key, /)
>  |      Return self[key].
>  |  
>  |  __gt__(self, value, /)
>  |      Return self>value.
>  |  
>  |  __hash__(self, /)
>  |      Return hash(self).
>  |  
>  |  __iter__(self, /)
>  |      Implement iter(self).
>  |  
>  |  __le__(self, value, /)
>  |      Return self<=value.
>  |  
>  |  __len__(self, /)
>  |      Return len(self).
>  |  
>  |  __lt__(self, value, /)
>  |      Return self<value.
>  |  
>  |  __ne__(self, value, /)
>  |      Return self!=value.
>  |  
>  |  __new__(*args, **kwargs) from builtins.type
>  |      Create and return a new object.  See help(type) for accurate signature.
>  |  
>  |  __reduce__(...)
>  |  
>  |  __repr__(self, /)
>  |      Return repr(self).
>  |  
>  |  __reversed__(...)
>  |      Return a reverse iterator.
>  |  
>  |  count(...)
>  |      rangeobject.count(value) -> integer -- return number of occurrences of value
>  |  
>  |  index(...)
>  |      rangeobject.index(value, [start, [stop]]) -> integer -- return index of value.
>  |      Raise ValueError if the value is not present.
>  |  
>  |  ----------------------------------------------------------------------
>  |  Data descriptors defined here:
>  |  
>  |  start
>  |  
>  |  step
>  |  
>  |  stop
> ```

#### 函数语法:

```
range(start, stop[, step])
```

#### 参数说明：

- start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;
- end: 计数到 end 结束，但不包括 end。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5
- step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)

#### 扩展：

- **they are their own iterators—after you step through their results once, they are ex-hausted**. In other words, you can’t have multiple iterators on their results that maintain different positions in those results.


- **multiple iterators are usually supported by returning new objects for the iter call**

#### 实例:

```
# Python 2.X
--------------------------------------------------------------------------------
>>>range(10)        # 从 0 开始到 10
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> range(1, 11)     # 从 1 开始到 11
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> range(0, 30, 5)  # 步长为 5
[0, 5, 10, 15, 20, 25]
>>> range(0, 10, 3)  # 步长为 3
[0, 3, 6, 9]
>>> range(0, -10, -1) # 负数
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
>>> range(0)
[]
>>> range(1, 0)
[]

# Python 3.X
--------------------------------------------------------------------------------
>>> list(range(-5, 5))
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
>>> list(range(5, -5, -1))
[5, 4, 3, 2, 1, 0, -1, -2, -3, -4]

>>> R = range(10)			# range returns an iterable, not a list
>>> R 
range(0, 10)

>>> I = iter(R)				# Make an iterator from the range iterable
>>> next(I) 				# Advance to next result
0							# What happens in for loops, comprehensions, etc.
>>> next(I) 
1
>>> next(I) 
2

>>> list(range(10)) 		# To force a list if required
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> len(R) 					# range also does len and indexing, but no others
10
>>> R[0] 
0
>>> R[-1] 
9

>>> next(I) 				# Continue taking from iterator, where left off
3
>>> I.__next__() 			# .next() becomes .__next__(), but use new next()
4
```





## sorted()

**sorted()** 函数对所有可迭代的对象进行排序操作。

#### **sort 与 sorted 区别：**

- sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。


- list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。

> ```
> # Python 2.X
>
> sorted(...)
>     sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list
> ```

> ```
> # Python 3.X
>
> sorted(...)
>     sorted(iterable, key=None, reverse=False) --> new sorted list
> ```

#### 函数语法:

```
sorted(iterable[, cmp[, key[, reverse]]])
```

#### 参数说明：

- iterable -- 可迭代对象。
- cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
- key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
- reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。

#### 返回值:

返回重新排序的列表。

#### 实例:

```
>>>a = [5,7,6,3,4,1,2]
>>> b = sorted(a)       # 保留原列表
>>> a 
[5, 7, 6, 3, 4, 1, 2]
>>> b
[1, 2, 3, 4, 5, 6, 7]
 
>>> L=[('b',2),('a',1),('c',3),('d',4)]
>>> sorted(L, cmp=lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数
[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
>>> sorted(L, key=lambda x:x[1])               # 利用key
[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
 
 
>>> students = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
>>> sorted(students, key=lambda s: s[2])            # 按年龄排序
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
 
>>> sorted(students, key=lambda s: s[2], reverse=True)       # 按降序
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
```



## str()

str() 函数将对象转化为适于人阅读的形式。

> ```
> class str(object)
>  |  str(object='') -> str
>  |  str(bytes_or_buffer[, encoding[, errors]]) -> str
>  |  
>  |  Create a new string object from the given object. If encoding or
>  |  errors is specified, then the object must expose a data buffer
>  |  that will be decoded using the given encoding and error handler.
>  |  Otherwise, returns the result of object.__str__() (if defined)
>  |  or repr(object).
>  |  encoding defaults to sys.getdefaultencoding().
>  |  errors defaults to 'strict'.
>  |  
>  |  Methods defined here:
>  |  
>  |  __add__(self, value, /)
>  |      Return self+value.
>  |  
>  |  __contains__(self, key, /)
>  |      Return key in self.
>  |  
>  |  __eq__(self, value, /)
>  |      Return self==value.
>  |  
>  |  __format__(...)
>  |      S.__format__(format_spec) -> str
>  |      
>  |      Return a formatted version of S as described by format_spec.
>  |  
>  |  __ge__(self, value, /)
>  |      Return self>=value.
>  |  
>  |  __getattribute__(self, name, /)
>  |      Return getattr(self, name).
>  |  
>  |  __getitem__(self, key, /)
>  |      Return self[key].
>  |  
>  |  __getnewargs__(...)
>  |  
>  |  __gt__(self, value, /)
>  |      Return self>value.
>  |  
>  |  __hash__(self, /)
>  |      Return hash(self).
>  |  
>  |  __iter__(self, /)
>  |      Implement iter(self).
>  |  
>  |  __le__(self, value, /)
>  |      Return self<=value.
>  |  
>  |  __len__(self, /)
>  |      Return len(self).
>  |  
>  |  __lt__(self, value, /)
>  |      Return self<value.
>  |  
>  |  __mod__(self, value, /)
>  |      Return self%value.
>  |  
>  |  __mul__(self, value, /)
>  |      Return self*value.n
>  |  
>  |  __ne__(self, value, /)
>  |      Return self!=value.
>  |  
>  |  __new__(*args, **kwargs) from builtins.type
>  |      Create and return a new object.  See help(type) for accurate signature.
>  |  
>  |  __repr__(self, /)
>  |      Return repr(self).
>  |  
>  |  __rmod__(self, value, /)
>  |      Return value%self.
>  |  
>  |  __rmul__(self, value, /)
>  |      Return self*value.
>  |  
>  |  __sizeof__(...)
>  |      S.__sizeof__() -> size of S in memory, in bytes
>  |  
>  |  __str__(self, /)
>  |      Return str(self).
>  |  
>  |  capitalize(...)
>  |      S.capitalize() -> str
>  |      
>  |      Return a capitalized version of S, i.e. make the first character
>  |      have upper case and the rest lower case.
>  |  
>  |  casefold(...)
>  |      S.casefold() -> str
>   |  
>  |  center(...)
>  |      S.center(width[, fillchar]) -> str
>  |      
>  |      Return S centered in a string of length width. Padding is
>  |      done using the specified fill character (default is a space)
>  |  
>  |  count(...)
>  |      S.count(sub[, start[, end]]) -> int
>  |      
>  |      Return the number of non-overlapping occurrences of substring sub in
>  |      string S[start:end].  Optional arguments start and end are
>  |      interpreted as in slice notation.
>  |  
>  |  encode(...)
>  |      S.encode(encoding='utf-8', errors='strict') -> bytes
>  |      
>  |      Encode S using the codec registered for encoding. Default encoding
>  |      is 'utf-8'. errors may be given to set a different error
>  |      handling scheme. Default is 'strict' meaning that encoding errors raise
>  |      a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
>  |      'xmlcharrefreplace' as well as any other name registered with
>  |      codecs.register_error that can handle UnicodeEncodeErrors.
>  |  
>  |  endswith(...)
>  |      S.endswith(suffix[, start[, end]]) -> bool
>  |      
>  |      Return True if S ends with the specified suffix, False otherwise.
>  |      With optional start, test S beginning at that position.
>  |      With optional end, stop comparing S at that position.
>  |      suffix can also be a tuple of strings to try.
>  |  
>  |  expandtabs(...)
>  |      S.expandtabs(tabsize=8) -> str
>  |      
>  |      Return a copy of S where all tab characters are expanded using spaces.
>  |      If tabsize is not given, a tab size of 8 characters is assumed.
>  |  
>  |  find(...)
>  |      S.find(sub[, start[, end]]) -> int
>  |      
>  |      Return the lowest index in S where substring sub is found,
>  |      such that sub is contained within S[start:end].  Optional
>  |      arguments start and end are interpreted as in slice notation.
>  |      
>  |      Return -1 on failure.
>  |  
>  |  format(...)
>  |      S.format(*args, **kwargs) -> str
>  |      
>  |      Return a formatted version of S, using substitutions from args and kwargs.
>  |      The substitutions are identified by braces ('{' and '}').
>  |  
>  |  format_map(...)
>  |      S.format_map(mapping) -> str
>  |      
>  |      Return a formatted version of S, using substitutions from mapping.
>  |      The substitutions are identified by braces ('{' and '}').
>  |  
>  |  index(...)
>  |      S.index(sub[, start[, end]]) -> int
>  |      
>  |      Like S.find() but raise ValueError when the substring is not found.
>  |  
>  |  isalnum(...)
>  |      S.isalnum() -> bool
>  |      
>  |      Return True if all characters in S are alphanumeric
>  |      and there is at least one character in S, False otherwise.
>  |  
>  |  isalpha(...)
>  |      S.isalpha() -> bool
>  |      
>  |      Return True if all characters in S are alphabetic
>  |      and there is at least one character in S, False otherwise.
>  |  
>  |  isdecimal(...)
>  |      S.isdecimal() -> bool
>  |      
>  |      Return True if there are only decimal characters in S,
>  |      False otherwise.
>  |  
>  |  isdigit(...)
>  |      S.isdigit() -> bool
>  |      
>  |      Return True if all characters in S are digits
>  |      and there is at least one character in S, False otherwise.
>  |  
>  |  
>  |  isidentifier(...)
>  |      S.isidentifier() -> bool
>  |      
>  |      Return True if S is a valid identifier according
>  |      to the language definition.
>  |      
>  |      Use keyword.iskeyword() to test for reserved identifiers
>  |      such as "def" and "class".
>  |  
>  |  islower(...)
>  |      S.islower() -> bool
>  |      
>  |      Return True if all cased characters in S are lowercase and there is
>  |      at least one cased character in S, False otherwise.
>  |  
>  |  isnumeric(...)
>  |      S.isnumeric() -> bool
>  |      
>  |      Return True if there are only numeric characters in S,
>  |      False otherwise.
>  |  
>  |  isprintable(...)
>  |      S.isprintable() -> bool
>  |      
>  |      Return True if all characters in S are considered
>  |      printable in repr() or S is empty, False otherwise.
>  |  
>  |  isspace(...)
>  |      S.isspace() -> bool
>  |      
>  |      Return True if all characters in S are whitespace
>  |      and there is at least one character in S, False otherwise.
>  |  
>  |  istitle(...)
>  |      S.istitle() -> bool
>  |      
>  |      Return True if S is a titlecased string and there is at least one
>  |      character in S, i.e. upper- and titlecase characters may only
>  |      follow uncased characters and lowercase characters only cased ones.
>  |      Return False otherwise.
>  |  
>  |  isupper(...)
>  |      S.isupper() -> bool
>  |      
>  |      Return True if all cased characters in S are uppercase and there is
>  |      at least one cased character in S, False otherwise.
>  |  
>  |  join(...)
>  |      S.join(iterable) -> str
>  |      
>  |      Return a string which is the concatenation of the strings in the
>  |      iterable.  The separator between elements is S.
>  |  
>  |  ljust(...)
>  |      S.ljust(width[, fillchar]) -> str
>  |      
>  |      Return S left-justified in a Unicode string of length width. Padding is
>  |      done using the specified fill character (default is a space).
>  |  
>  |  lower(...)
>  |      S.lower() -> str
>  |      
>  |      Return a copy of the string S converted to lowercase.
>  |  
>  |  lstrip(...)
>  |      S.lstrip([chars]) -> str
>  |      
>  |      Return a copy of the string S with leading whitespace removed.
>  |      If chars is given and not None, remove characters in chars instead.
>  |  
>  |  partition(...)
>  |      S.partition(sep) -> (head, sep, tail)
>  |      
>  |      Search for the separator sep in S, and return the part before it,
>  |      the separator itself, and the part after it.  If the separator is not
>  |      found, return S and two empty strings.
>  |  
>  |  replace(...)
>  |      S.replace(old, new[, count]) -> str
>  |      
>  |      Return a copy of S with all occurrences of substring
>  |      old replaced by new.  If the optional argument count is
>  |      given, only the first count occurrences are replaced.
>  |  rfind(...)
>  |      S.rfind(sub[, start[, end]]) -> int
>  |      
>  |      Return the highest index in S where substring sub is found,
>  |      such that sub is contained within S[start:end].  Optional
>  |      arguments start and end are interpreted as in slice notation.
>  |      
>  |      Return -1 on failure.
>  |  
>  |  rindex(...)
>  |      S.rindex(sub[, start[, end]]) -> int
>  |      
>  |      Like S.rfind() but raise ValueError when the substring is not found.
>  |  
>  |  rjust(...)
>  |      S.rjust(width[, fillchar]) -> str
>  |      
>  |      Return S right-justified in a string of length width. Padding is
>  |      done using the specified fill character (default is a space).
>  |  
>  |  rpartition(...)
>  |      S.rpartition(sep) -> (head, sep, tail)
>  |      
>  |      Search for the separator sep in S, starting at the end of S, and return
>  |      the part before it, the separator itself, and the part after it.  If the
>  |      separator is not found, return two empty strings and S.
>  |  
>  |  rsplit(...)
>  |      S.rsplit(sep=None, maxsplit=-1) -> list of strings
>  |      
>  |      Return a list of the words in S, using sep as the
>  |      delimiter string, starting at the end of the string and
>  |      working to the front.  If maxsplit is given, at most maxsplit
>  |      splits are done. If sep is not specified, any whitespace string
>  |      is a separator.
>  |  
>  |  rstrip(...)
>  |      S.rstrip([chars]) -> str
>  |      
>  |      Return a copy of the string S with trailing whitespace removed.
>  |      If chars is given and not None, remove characters in chars instead.
>  |  
>  |  split(...)
>  |      S.split(sep=None, maxsplit=-1) -> list of strings
>  |      
>  |      Return a list of the words in S, using sep as the
>  |      delimiter string.  If maxsplit is given, at most maxsplit
>  |      splits are done. If sep is not specified or is None, any
>  |      whitespace string is a separator and empty strings are
>  |      removed from the result.
>  |  
>  |  splitlines(...)
>  |      S.splitlines([keepends]) -> list of strings
>  |      
>  |      Return a list of the lines in S, breaking at line boundaries.
>  |      Line breaks are not included in the resulting list unless keepends
>  |      is given and true.
>  |  
>  |  startswith(...)
>  |      S.startswith(prefix[, start[, end]]) -> bool
>  |      
>  |      Return True if S starts with the specified prefix, False otherwise.
>  |      With optional start, test S beginning at that position.
>  |      With optional end, stop comparing S at that position.
>  |      prefix can also be a tuple of strings to try.
>  |  
>  |  strip(...)
>  |      S.strip([chars]) -> str
>  |      
>  |      Return a copy of the string S with leading and trailing
>  |      whitespace removed.
>  |      If chars is given and not None, remove characters in chars instead.
>  |  
>  |  swapcase(...)
>  |      S.swapcase() -> str
>  |      
>  |      Return a copy of S with uppercase characters converted to lowercase
>  |      and vice versa.
>  |  
>  |  title(...)
>  |      S.title() -> str
>  |      
>  |      Return a titlecased version of S, i.e. words start with title case
>  |      characters, all remaining cased characters have lower case.
>  |  
>  |  translate(...)
>  |      S.translate(table) -> str
>  |      
>  |      Return a copy of the string S, where all characters have been mapped
>  |      through the given translation table, which must be a mapping of
>  |      Unicode ordinals to Unicode ordinals, strings, or None.
>  |      Unmapped characters are left untouched. Characters mapped to None
>  |      are deleted.
>  |  
>  |  upper(...)
>  |      S.upper() -> str
>  |      
>  |      Return a copy of S converted to uppercase.
>  |  
>  |  zfill(...)
>  |      S.zfill(width) -> str
>  |      
>  |      Pad a numeric string S with zeros on the left, to fill a field
>  |      of the specified width. The string S is never truncated.
>  |  
>  |  ----------------------------------------------------------------------
>  |  Static methods defined here:
>  |  
>  |  maketrans(x, y=None, z=None, /)
>  |      Return a translation table usable for str.translate().
>  |      
>  |      If there is only one argument, it must be a dictionary mapping Unicode
>  |      ordinals (integers) or characters to Unicode ordinals, strings or None.
>  |      Character keys will be then converted to ordinals.
>  |      If there are two arguments, they must be strings of equal length, and
>  |      in the resulting dictionary, each character in x will be mapped to the
>  |      character at the same position in y. If there is a third argument, it
>  |      must be a string, whose characters will be mapped to None in the result.
> ```

#### 函数语法:

```
class str(object='')
```

#### 参数说明：

- object -- 对象。

#### 返回值:

返回一个对象的string格式。

#### 实例:

```

```







## type()

type() 函数如果你只有第一个参数则返回对象的类型，三个参数返回新的类型对象。

> isinstance() 与 type() 区别：
>
> - type() 不会认为子类是一种父类类型，不考虑继承关系。
> - isinstance() 会认为子类是一种父类类型，考虑继承关系。
>
> 如果要判断两个类型是否相同推荐使用 isinstance()。

> ```
> class type(object)
>  |  type(object_or_name, bases, dict)
>  |  type(object) -> the object's type
>  |  type(name, bases, dict) -> a new type
>  |  
>  |  Methods defined here:
>  |  
>  |  __call__(self, /, *args, **kwargs)
>  |      Call self as a function.
>  |  
>  |  __delattr__(self, name, /)
>  |      Implement delattr(self, name).
>  |  
>  |  __dir__(...)
>  |      __dir__() -> list
>  |      specialized __dir__ implementation for types
>  |  
>  |  __getattribute__(self, name, /)
>  |      Return getattr(self, name).
>  |  
>  |  __init__(self, /, *args, **kwargs)
>  |      Initialize self.  See help(type(self)) for accurate signature.
>  |  
>  |  __instancecheck__(...)
>  |      __instancecheck__() -> bool
>  |      check if an object is an instance
>  |  
>  |  __new__(*args, **kwargs)
>  |      Create and return a new object.  See help(type) for accurate signature.
>  |  
>  |  __prepare__(...)
>  |      __prepare__() -> dict
>  |      used to create the namespace for the class statement
>  |  
>  |  __repr__(self, /)
>  |      Return repr(self).
>  |  
>  |  __setattr__(self, name, value, /)
>  |      Implement setattr(self, name, value).
>  |  
>  |  __sizeof__(...)
>  |      __sizeof__() -> int
>  |      return memory consumption of the type object
>  |  
>  |  __subclasscheck__(...)
>  |      __subclasscheck__() -> bool
>  |      check if a class is a subclass
>  |  
>  |  __subclasses__(...)
>  |      __subclasses__() -> list of immediate subclasses
>  |  
>  |  mro(...)
>  |      mro() -> list
>  |      return a type's method resolution order
>  |  
>  |  ----------------------------------------------------------------------
>  |  Data descriptors defined here:
>  |  
>  |  __abstractmethods__
>  |  
>  |  __dict__
>  |  
>  |  __text_signature__
>  |  
>  |  ----------------------------------------------------------------------
>  |  Data and other attributes defined here:
>  |  
>  |  __base__ = <class 'object'>
>  |      The most base type
>  |  
>  |  __bases__ = (<class 'object'>,)
>  |  
>  |  __basicsize__ = 824
>  |  
>  |  __dictoffset__ = 264
>  |  
>  |  __flags__ = 2148291584
>  |  
>  |  __itemsize__ = 40
>  |  
>  |  __mro__ = (<class 'type'>, <class 'object'>)
>  |  
>  |  __weakrefoffset__ = 368
> ```

#### 函数语法:

```
class type(name, bases, dict)
```

#### 参数说明：

- name -- 类的名称。
- bases -- 基类的元组。
- dict -- 字典，类内定义的命名空间变量。

#### 返回值:

一个参数返回对象类型, 三个参数，返回新的类型对象。

#### 实例:

```
# 一个参数实例
>>> type(1)
<class 'int'>
>>> type('apple')
<class 'str'>
>>> type([2])
<class 'list'>
>>> type({0:'zero'})
<class 'dict'>
>>> x = 1
>>> type(x) == int		# 判断类型是否相等
True

# 三个参数
>>> class D(object):
...     a = 1
... 
>>> D = type('D', (object,), dict(a=1))		# 产生一个新的类型 D
>>> D
<class '__main__.D'>
```

#### type() 与 isinstance() 区别：

```
class A:
    pass
 
class B(A):
    pass
 
isinstance(A(), A)    # returns True
type(A()) == A        # returns True
isinstance(B(), A)    # returns True
type(B()) == A        # returns False
```





## zip()

**zip()** 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。

如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

> ```
> class zip(object)
>  |  zip(iter1 [,iter2 [...]]) --> zip object
>  |  
>  |  Return a zip object whose .__next__() method returns a tuple where
>  |  the i-th element comes from the i-th iterable argument.  The .__next__()
>  |  method continues until the shortest iterable in the argument sequence
>  |  is exhausted and then it raises StopIteration.
>  |  
>  |  Methods defined here:
>  |  
>  |  __getattribute__(self, name, /)
>  |      Return getattr(self, name).
>  |  
>  |  __iter__(self, /)
>  |      Implement iter(self).
>  |  
>  |  __new__(*args, **kwargs) from builtins.type
>  |      Create and return a new object.  See help(type) for accurate signature.
>  |  
>  |  __next__(self, /)
>  |      Implement next(self).
>  |  
>  |  __reduce__(...)
>  |      Return state information for pickling.
> ```

#### 函数语法:

```
zip([iterable, ...])
```

#### 参数说明：

- iterabl -- 一个或多个迭代器;

#### 返回值:

返回元组列表。

#### 扩展：

- **they are their own iterators—after you step through their results once, they are ex-hausted**. In other words, you can’t have multiple iterators on their results that maintain different positions in those results.
- **a single iterator generally means an object returns itself**

#### 实例:

```
# Python 2.X
--------------------------------------------------------------------------------
>>>a = [1,2,3]
>>> b = [4,5,6]
>>> c = [4,5,6,7,8]
>>> zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
>>> zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
>>> zip(*zipped)          # 与 zip 相反，可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]

# Python 3.X
--------------------------------------------------------------------------------
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> zip(a,b)
<zip object at 0x10103ea48>
>>> list(zip(a,b))			# list() required in 3.X, not 2.X
[(1, 4), (2, 5), (3, 6)]

>>> Z = zip((1, 2, 3), (10, 20, 30))		# zip is the same: a one-pass iterator
>>> Z 
<zip object at 0x0000000002951108>

>>> list(Z) 
[(1, 10), (2, 20), (3, 30)]

>>> for pair in Z: print(pair) 				# Exhausted after one pass
...

>>> Z = zip((1, 2, 3), (10, 20, 30))
>>> for pair in Z: print(pair) 				# Iterator used automatically or manually
...
(1, 10) 
(2, 20) 
(3, 30)

>>> Z = zip((1, 2, 3), (10, 20, 30))		# Manual iteration (iter() not needed)
>>> next(Z) 
(1, 10)
>>> next(Z) 
(2, 20)
```

parallel iterations:

```
>>> L1 = [1,2,3,4]
>>> L2 = [5,6,7,8]
>>> for (x, y) in zip(L1, L2): 
... 	print(x, y, '--', x+y) 
...
1 5 -- 6 
2 6 -- 8 
3 7 -- 10 
4 8 -- 12
```

> Notice that this for loop again uses the tuple assignment form we met earlier to unpack each tuple in the zip result. The first time through, it’s as though we ran the assignment statement (x, y) = (1, 5).



**the `zip` function**, it **accepts any type of sequence** (really, any iterable object, including files), and it **accepts more than two arguments**.

```
>>> T1, T2, T3 = (1,2,3), (4,5,6), (7,8,9)
>>> T3 
(7, 8, 9)
>>> list(zip(T1, T2, T3)) 			# Three tuples for three arguments
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
```



#### map equivalence in Python 2.X

`zip` truncates result tuples at the length of the shortest sequence when the argument lengths differ.

```
>>> S1 = 'abc'
>>> S2 = 'xyz123'

>>> map(None, S1, S2) 			# 2.X only: pads to len(longest) 
[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None,'3')]
```

```
>>> list(map(ord, 'spam')) 
[115, 112, 97, 109]
```

`map` is often quicker

```
>>> res = []
>>> for c in 'spam': res.append(ord(c))
>>> res 
[115, 112, 97, 109]
```



#### Dictionary construction with `zip`

```
>>> keys = ['spam', 'eggs', 'toast']
>>> vals = [1, 3, 5]

>>> list(zip(keys, vals)) 
[('spam', 1), ('eggs', 3), ('toast', 5)]

>>> D2 = {}
>>> for (k, v) in zip(keys, vals): D2[k] = v 
...
>>> D2 
{'eggs': 3, 'toast': 5, 'spam': 1}
```

in Python 2.2 and later you can skip the for loop altogether and simply pass the zipped keys/values lists to the built-in dict constructor call:

```
>>> keys = ['spam', 'eggs', 'toast']
>>> vals = [1, 3, 5]

>>> D3 = dict(zip(keys, vals))
>>> D3 
{'eggs': 3, 'toast': 5, 'spam': 1}
```

> The built-in name dict is really a type name in Python. Calling it achieves something like a list-to-dictionary conversion, but it’s really an object construction request.