# Functions 函数 



## Function Basics

- Maximizing code reuse and minimizing redundancy

- Procedural decomposition

  > In general, functions are about procedure—how to do something, rather than what you’re doing it to.

a set that includes call expressions, two ways to make functions (`def` and `lambda`), two ways to manage scope visibility (`global` and `nonlocal`), and two ways to send results back to callers (`return` and `yield`).

```
Function-related statements and expressions

Statement or expression		Examples
--------------------------------------------------------------------------------
Call expressions			myfunc('spam', 'eggs', meat=ham, *rest)
--------------------------------------------------------------------------------
def							def printer(messge):
								print('Hello ' + message)
--------------------------------------------------------------------------------
return						def adder(a, b=1, *c):
								return a + b + c[0]
--------------------------------------------------------------------------------				global						x = 'old' 
							def changer():
								global x; x = 'new'
--------------------------------------------------------------------------------
nonlocal (3.X)				def outer():
								x = 'old' 
								def changer():
									nonlocal x; x = 'new'		
--------------------------------------------------------------------------------				
yield						def squares(x):
								for i in range(x): yield i ** 2
--------------------------------------------------------------------------------				
lambda						funcs = [lambda x: x**2, lambda x: x**3]
```



### Coding Functions 编写函数

Here is a brief introduction to the main concepts behind Python functions:

- **def is executable code.** 

  > Python functions are written with a new statement, the `def`. Unlike functions in compiled languages such as C, `def` is an executable state-ment—your function does not exist until Python reaches and runs the `def`. In fact, it’s legal (and even occasionally useful) to nest `def` statements inside if statements, while loops, and even other `def`s. In typical operation, `def` statements are coded in module files and are naturally run to generate functions when the module file they reside in is first imported.

- **def creates an object and assigns it to a name.** 

  > When Python reaches and runs a `def` statement, it generates a new function object and assigns it to the function’s name. As with all assignments, the function name becomes a reference to the function object. the function object can be assigned to other names, stored in a list, and so on. Function objects may also have arbitrary user-defined attributes attached to them to record data.


- **lambda creates an object but returns it as a result.** 

  > Functions may also be created with the `lambda` expression, a feature that allows us to in-line function definitions in places where a `def` statement won’t work syntactically.


- **return sends a result object back to the caller.** 

  > When a function is called, the caller stops until the function finishes its work and returns control to the caller. Functions that compute a value send it back to the caller with a `return` statement; the returned value becomes the result of the function call. A `return` without a value simply returns to the caller (and sends back `None`, the default result).


- **yield sends a result object back to the caller, but remembers where it left off.**

  > Functions known as generators may also use the yield statement to send back a value and suspend their state such that they may be resumed later, to produce a series of results over time. 

- **global declares module-level variables that are to be assigned.** 

  > By default, all names assigned in a function are local to that function and exist only while the function runs. To assign a name in the enclosing module, functions need to list it in a `global` statement. More generally, names are always looked up in scopes—places where variables are stored—and assignments bind names to scopes.


- **nonlocal declares enclosing function variables that are to be assigned.** 

  > Similarly, the `nonlocal` statement added in Python 3.X allows a function to assign a name that exists in the scope of a syntactically enclosing `def` statement. This allows enclosing functions to serve as a place to retain state—information remembered between function calls—without using shared global names.


- **Arguments are passed by assignment (object reference).** 

  > In Python, arguments are passed to functions by assignment (which, as we’ve learned, means by object reference). As you’ll see, in Python’s model the caller and function share objects by references, but there is no name aliasing. Changing an argument name within a function does not also change the corresponding name in the caller, but changing passed-in mutable objects in place can change objects shared by the caller, and serve as a function result.


- **Arguments are passed by position, unless you say otherwise.** 

  > Values you pass in a function call match argument names in a function’s definition from left to right by default. For flexibility, function calls can also pass arguments by name with `name=value` keyword syntax, and unpack arbitrarily many arguments to send with `*pargs` and `**kargs` starred-argument notation. Function definitions use the same two forms to specify argument defaults, and collect arbitrarily many arguments received.


- **Arguments, return values, and variables are not declared.** 

  > As with everything in Python, there are no type constraints on functions. In fact, nothing about a function needs to be declared ahead of time: you can pass in arguments of any type, return any kind of object, and so on. As one consequence, a single function can often be applied to a variety of object types—any objects that sport a compatible interface (methods and expressions) will do, regardless of their specific types.



#### def Statements

The `def` statement creates a function object and assigns it to a name. Its general format is as follows:

```
def name(arg1, arg2,... argN):
	statements
```

> As with all compound Python statements, `def` consists of a header line followed by a block of statements, usually indented (or a simple statement after the colon). The statement block becomes the function’s body—that is, the code Python executes each time the function is later called.

> The `def` header line specifies a function name that is assigned the function object, along with a list of zero or more arguments (sometimes called parameters) in parentheses. The argument names in the header are assigned to the objects passed in parentheses at the point of call.

Function bodies often contain a `return` statement:

```
def name(arg1, arg2,... argN):
	...
	return value
```

> The Python `return` statement can show up anywhere in a function body; when reached, it ends the function call and sends a result back to the caller. The `return` statement consists of an optional object value expression that gives the function’s result. If the value is omitted, `return` sends back a `None`.
>
> The `return` statement itself is optional too; if it’s not present, the function exits when the control flow falls off the end of the function body. Technically, a function without a `return` statement also returns the `None` object automatically, but this return value is usually ignored at the call.
>
> Functions may also contain `yield` statements, which are designed to produce a series of values over time

#### def Executes at Runtime

The Python `def` is a true executable statement: when it runs, it creates a new function object and assigns it to a name. (Remember, all we have in Python is runtime; there is no such thing as a separate compile time.)

```
if test:
	def func():			# Define func this way
		... 
else:
	def func():			# Or else this way
		... 
...
func()					# Call the version selected and built
```

Python functions do not need to be fully defined before the program runs. More generally, `def`s are not evaluated until they are reached and run, and the code inside `def`s is not evaluated until the functions are later called.

```
othername = func 		# Assign function object
othername()				# Call func again

def func(): ... 		# Create function object
func() 					# Call object
func.attr = value		# Attach attributes
```

Like everything else in Python, functions are just objects; they are recorded explicitly in memory at program execution time. In fact, besides calls, functions allow arbitrary attributes to be attached to record information for later use



### Example: Definitions and Calls

#### Definition

```
>>> def times(x, y): 		# Create and assign function
... 	return x * y 		# Body executed when called
...
```

> When Python reaches and runs this `def`, it creates a new function object that packages the function’s code and assigns the object to the name times. Typically, such a statement is coded in a module file and runs when the enclosing file is imported

#### Calls

The `def` statement makes a function but does not call it. After the `def` has run, you can call (run) the function in your program by adding parentheses after the function’s name. The parentheses may optionally contain one or more object arguments, to be passed (assigned) to the names in the function’s header:

```
>>> times(2, 4) 		# Arguments in parentheses
8

>>> x = times(3.14, 4)		# Save the result object
>>> x
12.56

>>> times('Ni', 4) 		# Functions are "typeless"
'NiNiNiNi'
```

#### Polymorphism in Python 多态

Python 将对某一对象在某种语法的合理性交由对象自身来判断，This sort of type-dependent behavior is known as polymorphism, means that the meaning of an operation depends on the objects being operated upon.

> for instance, can generally be applied to a whole category of object types automatically. As long as those objects support the expected interface (a.k.a. protocol), the function can process them. That is, if the objects passed into a function have the expected methods and expression operators, they are plug-and-play compatible with the function’s logic.
>
> Moreover, if the objects passed in do not support this expected interface, Python will detect the error when the * expression is run and raise an exception automatically. It’s therefore usually pointless to code error checking ourselves. In fact, doing so would limit our function’s utility, as it would be restricted to work only on objects whose types we test for.

in Python, your code is not supposed to care about specific data types. （philosophical difference between Python and statically typed languages like C++ and Java）

> If it does, it will be limited to working on just the types you anticipated when you wrote it, and it will not support other compatible object types that may be coded in the future. Although it is possible to test for types with tools like the type built-in function, doing so breaks your code’s flexibility. 

By and large, we code to object interfaces in Python, not data types. 

Of course, some programs have unique requirements, and this polymorphic model of programming means we have to test our code to detect errors, rather than providing type declarations a compiler can use to detect some types of errors for us ahead of time.

>  In exchange for an initial bit of testing, though, we radically reduce the amount of code we have to write and radically increase our code’s flexibility. As you’ll learn, it’s a net win in practice.



### Example: Intersecting Sequences

#### Definition

- Putting the code in a function makes it a tool that you can run as many times as you like.


- Because callers can pass in arbitrary arguments, functions are general enough to work on any two sequences (or other iterables) you wish to intersect.



- When the logic is packaged in a function, you have to change code in only one place if you ever need to change the way the intersection works.



- Coding the function in a module file means it can be imported and reused by any program run on your machine.

wrapping the code in a function makes it a general intersection utility:

```
def intersect(seq1, seq2):
	res = [] 				# Start empty
	for x in seq1:			# Scan seq1
		if x in seq2: 		# Common item?
			res.append(x) 	# Add to end
	return res
```

#### Calls

```
>>> s1 = "SPAM"
>>> s2 = "SCAM"
>>> intersect(s1, s2) 		# Strings
['S', 'A', 'M']
```

the function could be replaced with a single list comprehension expression, as it exhibits the classic loop collector code pattern:

```
>>> [x for x in s1 if x in s2] 
['S', 'A', 'M']
```

#### Local Variables

the variable `res` inside `intersect` is what in Python is called a local variable—a name that is visible only to code inside the function `def` and that exists only while the function runs. In fact, because all names assigned in any way inside a function are classified as local variables by default, nearly all the names in `intersect` are local vari-ables:

- `res` is obviously assigned, so it is a local variable.


- Arguments are passed by assignment, so `seq1` and `seq2` are, too.



- The `for` loop assigns items to a variable, so the name `x` is also local.

All these local variables appear when the function is called and disappear when the function exits



## Scopes 作用域

When you use a name in a program, Python creates, changes, or looks up the name in what is known as a namespace—a place where names live. When we talk about the search for a name’s value in relation to code, the term scope refers to a namespace: that is, the location of a name’s assignment in your source code determines the scope of the name’s visibility to your code.

Just about everything related to names, including scope classification, happens at assignment time in Python. As we’ve seen, names in Python spring into existence when they are first assigned values, and they must be assigned before they are used. Because names are not declared ahead of time, Python uses the location of the assignment of a name to associate it with (i.e., bind it to) a particular namespace. In other words, the place where you assign a name in your source code determines the namespace it will live in, and hence its scope of visibility.

- Names assigned inside a `def` can only be seen by the code within that `def`. You cannot even refer to such names from outside the function.


- Names assigned inside a `def` do not clash with variables outside the `def`, even if the same names are used elsewhere. A name `X` assigned outside a given `def` (i.e., in a different `def` or at the top level of a module file) is a completely different variable from a name `X` assigned inside that `def`.

In all cases, the scope of a variable (where it can be used) is always determined by where it is assigned in your source code and has nothing to do with which functions call which. variables may be assigned in three different places, corresponding to three different scopes:

- If a variable is assigned inside a def, it is local to that function.


- If a variable is assigned in an enclosing def, it is nonlocal to nested functions.



- If a variable is assigned outside all defs, it is global to the entire file.

We call this **lexical scoping** because variable scopes are determined entirely by the locations of the variables in the source code of your program files, not by function calls.

For example：

```
X = 99				# Global (module) scope X

def func():
	X = 88			# Local (function) scope X: a different variable
```

> Even though both variables are named `X`, their scopes make them different. The net effect is that function scopes help to avoid name clashes in your programs and help to make functions more self-contained program units



Before we started writing functions, all the code we wrote was at the top level of a module (i.e., not nested in a def), so the names we used either lived in the module itself or were built-ins predefined by Python (e.g., `open`). Technically, the interactive prompt is a module named `__main__` that prints results and doesn’t save its code; in all other ways, though, it’s like the top level of a module file.

Functions, though, provide nested namespaces (scopes) that localize the names they use, such that names inside a function won’t clash with those outside it (in a module or another function). Functions define a local scope and modules define a global scope with the following properties:

- The enclosing module is a global scope. 

  > Each module is a global scope—that is, a namespace in which variables created (assigned) at the top level of the module file live. Global variables become attributes of a module object to the outside world after imports but can also be used as simple variables within the module file itself.


- The global scope spans a single file only. 

  > Don’t be fooled by the word “global” here—names at the top level of a file are global to code within that single file only. There is really no notion of a single, all-encompassing global file-based scope in Python. Instead, names are partitioned into modules, and you must always import a module explicitly if you want to be able to use the names its file defines. When you hear “global” in Python, think “module.”


- Assigned names are local unless declared global or nonlocal. 

  > By default, all the names assigned inside a function definition are put in the local scope (the namespace associated with the function call). If you need to assign a name that lives at the top level of the module enclosing the function, you can do so by declaring it in a `global` statement inside the function. If you need to assign a name that lives in an enclosing `def`, as of Python 3.X you can do so by declaring it in a `nonlocal` statement.


- All other names are enclosing function locals, globals, or built-ins. 

  > Names not assigned a value in the function definition are assumed to be enclosing scope locals, defined in a physically surrounding `def` statement; globals that live in the enclosing module’s namespace; or built-ins in the predefined built-ins module Python provides.


- Each call to a function creates a new local scope. 

  > Every time you call a function, you create a new local scope—that is, a namespace in which the names created inside that function will usually live. You can think of each `def` statement (and `lambda` expression) as defining a new local scope, but the local scope actually corresponds to a function call.

any type of assignment within a function classifies a name as local. This includes `=` statements, module names in `import`, function names in `def`, function argument names, and so on. If you assign a name in any way within a `def`, it will become a local to that function by default.

in-place changes to objects do not classify names as locals; only actual name assignments do.









## 抽象

计算数列的和，比如：`1 + 2 + 3 + ... + 100`，写起来十分不方便，于是数学家发明了求和符号∑，可以把 `1 + 2 + 3 + ... + 100` 记作：

$$\sum_{n=1}^{100} $$

这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。

而且，这种抽象记法是可扩展的，比如：

$$\sum_{n=1}^{100}{(n^2+1)}$$

还原成加法运算就变成了：

(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)

可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。



## 调用函数

要调用一个函数，需要知道函数的名称和参数。

调用 `abs` 函数：

```
>>> abs(100)
100
>>> abs(-20)
20
>>> abs(12.34)
12.34
```

调用函数的时候，如果传入的参数数量不对，会报 `TypeError` 的错误：

```
>>> abs(1, 2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: abs() takes exactly one argument (2 given)
```

传入的参数数量是对的，但参数类型不能被函数所接受，也会报`TypeError`的错误：

```
>>> abs('a')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: bad operand type for abs(): 'str'
```

函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量：

```
>>> a = abs 	# 变量a指向abs函数
>>> a(-1) 		# 所以也可以通过a调用abs函数
1
```



## 定义函数

在Python中，定义一个函数要使用 `def` 语句，依次写出函数名、括号、括号中的参数和冒号 `:`，然后，在缩进块中编写函数体，函数的返回值用 `return` 语句返回。

```
def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x
```

> 函数体内部的语句在执行时，一旦执行到`return`时，函数就执行完毕，并将结果返回。如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`None`。
>
> `return None` 可以简写为 `return`。



### 空函数

如果想定义一个什么事也不做的空函数，可以用 `pass` 语句, `pass` 语句什么都不做：

```
def nop():
    pass
```

> 实际上`pass`可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个`pass`，让代码能运行起来。
>
> ```
> if age >= 18:
>     pass		# 缺少了pass，代码运行就会有语法错误。
> ```



### 参数检查

调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出 `TypeError`：

```
>>> my_abs(1, 2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: my_abs() takes 1 positional argument but 2 were given
```

但是如果参数类型不对，Python解释器就无法帮我们检查:

```
>>> my_abs('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in my_abs
TypeError: unorderable types: str() >= int()
>>> abs('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: bad operand type for abs(): 'str'
```

> 当传入了不恰当的参数时，内置函数`abs`会检查出参数错误，而我们定义的`my_abs`没有参数检查，会导致`if`语句出错，出错信息和`abs`不一样。所以，这个函数定义不够完善。

修改一下 `my_abs` 的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数 `isinstance()` 实现：

```
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x
```

```
>>> my_abs('A')		# 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in my_abs
TypeError: bad operand type
```



### 返回多个值

Python的函数返回多值其实就是返回一个tuple.



## 函数的参数

定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了



### 位置参数

1. 对于 `power(x)` 函数，参数 `x` 就是一个位置参数。当我们调用`power`函数时，必须传入有且仅有的一个参数 `x`：

   ```
   >>> def power(x):
   ...     return x * x
   ... 
   >>> power(5)
   25
   ```


2. 对于 `power(x, n)` 函数有两个参数：`x`和`n`，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数`x`和`n`。

   ```
   >>> def power(x, n):
   ...     s = 1
   ...     while n > 0:
   ...         n = n - 1
   ...         s = s * x
   ...     return s
   ... 
   >>> power(5, 2)
   25
   ```

   缺少一个参数而无法正常调用：

   ```
   >>> power(5)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: power() missing 1 required positional argument: 'n'
   ```

> 参数个数不确定：
>
> 我们首先想到可以把a，b，c……作为一个list或tuple传进来，函数可以定义如下：
>
> ```
> >>> def calc(numbers):
> ...     sum = 0
> ...     for n in numbers:
> ...         sum = sum + n * n
> ...     return sum
> ... 
> >>> calc([1, 2, 3])		# 调用的时候，需要先组装出一个list或tuple
> 14
> >>> calc((1, 3, 5, 7))
> 84
> ```



### 默认参数

默认参数可以简化函数的调用。降低调用函数的难度。

设置默认参数时:

1. 必选参数在前，默认参数在后，否则Python的解释器会报错

2. 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

3. **默认参数必须指向不变对象！**

   > 因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

```
>>> def power(x, n=2):		# 第二个参数n的默认值设定为2
...     s = 1
...     while n > 0:
...         n = n - 1
...         s = s * x
...     return s
... 
>>> power(5)		# 当我们调用power(5)时，相当于调用power(5, 2)：
25
>>> power(5, 2)
25
```

**默认参数位置顺序：**

```
 def enroll(name, gender, age=6, city='Beijing'):
     print('name:', name)
     print('gender:', gender)
     print('age:', age)
     print('city:', city)
```

- **有多个默认参数调用的时候，可以按顺序提供默认参数**，比如调用`enroll('Bob', 'M', 7)`，意思是，除了`name`，`gender`这两个参数外，最后1个参数应用在参数`age`上，`city`参数由于没有提供，仍然使用默认值。
- **当不按顺序提供部分默认参数时，需要把参数名写上**。比如调用 `enroll('Adam', 'M', city='Tianjin')`，意思是，`city` 参数用传进去的值，其他默认参数继续使用默认值。



### 可变参数

可变参数就是传入的参数个数是可变的，允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。

定义可变参数在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple，调用该函数时，可以传入任意个参数，包括0个参数：

```
>>> def calc(*numbers):		 # 可变参数
...     sum = 0
...     for n in numbers:
...         sum = sum + n * n
...     return sum
... 
>>> calc(1, 2)
5
>>> calc()
0
```

1. 如果已经有一个list或者tuple，要调用一个可变参数可以这样做：

   ```
   >>> nums = [1, 2, 3]
   >>> calc(nums[0], nums[1], nums[2])
   14
   ```


2. Python允许你在list或tuple前面加一个`*`号，把list或tuple的元素变成可变参数传进去：

   ```
   >>> nums = [1, 2, 3]
   >>> calc(*nums)		# *nums表示把nums这个list的所有元素作为可变参数传进去。
   14
   ```



### 关键字参数

关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。

函数`person`除了必选参数`name`和`age`外，还接受关键字参数`kw` ：

```
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
```

在调用该函数时，可以只传入必选参数：

```
>>> person('Michael', 30)
name: Michael age: 30 other: {}
```

也可以传入任意个数的关键字参数：

```
>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
```

可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：

```
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

复杂的调用可以用简化的写法：

```
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。
```



### 命名关键字参数

> 对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过`kw`检查。
>
> 仍以`person()`函数为例，我们希望检查是否有`city`和`job`参数：
>
> ```
> def person(name, age, **kw):
>     if 'city' in kw:
>         # 有city参数
>         pass
>     if 'job' in kw:
>         # 有job参数
>         pass
>     print('name:', name, 'age:', age, 'other:', kw)
> ```
>
> 调用者仍可以传入不受限制的关键字参数：
>
> ```
> >>> person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)
> ```

如果要限制关键字参数的名字，就可以用命名关键字参数. 命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。

例如，只接收`city`和`job`作为关键字参数。这种方式定义的函数如下：

```
>>> def person(name, age, *, city, job):
...     print(name, age, city, job)
... 
>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
```

如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了：

```
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
```

命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：

```
>>> person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: person() takes 2 positional arguments but 4 were given
```

> 由于调用时缺少参数名`city`和`job`，Python解释器把这4个参数均视为位置参数，但`person()`函数仅接受2个位置参数。

命名关键字参数可以有缺省值，从而简化调用：

```
>>> def person(name, age, *, city='Beijing', job):
...     print(name, age, city, job)
... 
>>> person('Jack', 24, job='Engineer')	# 命名关键字参数city具有默认值，
Jack 24 Beijing Engineer				# 调用时，可不传入city参数
```

使用命名关键字参数时，如果没有可变参数，就必须加一个`*`作为特殊分隔符。如果缺少`*`，Python解释器将无法识别位置参数和命名关键字参数：

```
def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
```



### 参数组合

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，**参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。**

对于任意函数，都可以通过类似 `func(*args, **kw)` 的形式调用它，无论它的参数是如何定义的。

```
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
```

在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。

```
>>> f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
>>> f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
>>> f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
>>> f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
>>> f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
```

通过一个tuple和dict，你也可以调用上述函数：

```
>>> args = (1, 2, 3, 4)
>>> kw = {'d': 99, 'x': '#'}
>>> f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
>>> args = (1, 2, 3)
>>> kw = {'d': 88, 'x': '#'}
>>> f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
```



## 递归函数

在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。

递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

举个例子，我们来计算阶乘 `n! = 1 * 2 * 3 * ... * n` ，用函数 `fact(n)` 表示，可以看出：

`fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n`

所以，`fact(n)` 可以表示为 `n * fact(n-1)` ，只有 n=1 时需要特殊处理。

于是，`fact(n)` 用递归的方式写出来就是：

```
>>> def fact(n):
...     if n==1:
...         return 1
...     return n * fact(n - 1)
... 
>>> fact(1)
1
>>> fact(5)
120
>>> fact(20)
2432902008176640000
```

如果我们计算`fact(5)`，可以根据函数定义看到计算过程如下：

```
===> fact(5)
===> 5 * fact(4)
===> 5 * (4 * fact(3))
===> 5 * (4 * (3 * fact(2)))
===> 5 * (4 * (3 * (2 * fact(1))))
===> 5 * (4 * (3 * (2 * 1)))
===> 5 * (4 * (3 * 2))
===> 5 * (4 * 6)
===> 5 * 24
===> 120
```

**使用递归函数需要注意防止栈溢出。**

> 在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
>
> ```
> >>> fact(1000)
> Traceback (most recent call last):
>   File "<stdin>", line 1, in <module>
>   File "<stdin>", line 4, in fact
>   ...
>   File "<stdin>", line 4, in fact
> RuntimeError: maximum recursion depth exceeded in comparison
> ```

### 尾递归函数

解决递归调用栈溢出的方法是通过 尾递归 优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

上面的 `fact(n)` 函数由于 `return n * fact(n - 1)` 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：

```
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

可以看到，`return fact_iter(num - 1, num * product)` 仅返回递归函数本身，`num - 1` 和  `num * product` 在函数调用前就会被计算，不影响函数调用。

`fact(5)` 对应的 `fact_iter(5, 1)` 的调用如下：

```
===> fact_iter(5, 1)
===> fact_iter(4, 5)
===> fact_iter(3, 20)
===> fact_iter(2, 60)
===> fact_iter(1, 120)
===> 120
```

遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的 `fact(n)` 函数改成尾递归方式，也会导致栈溢出。