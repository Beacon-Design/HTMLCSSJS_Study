# Python Study Notes



# String 字符串

A string is a _sequence_ of _characters_.一串字符串（String）是 _字符（Characters）_ 的 _序列（Sequence）_

the characters they contain have a left-to-right positional order and that they cannot be changed in place.

> in Python we call a sequence—a positionally ordered collection of other objects. Sequences maintain a left-to-right order among the items they contain: their items are stored and fetched by their relative positions. Strictly speaking, strings are sequences of one-character strings; other, more general sequence types include lists and tuples

### Immutability

**Strings are Immutable in Python**

> they cannot be changed in place after they are created. you can never overwrite the values of immutable objects.

```
>>> S 
'Spam'

>>> S[0] = 'z' 				# Immutable objects cannot be changed 
...error text omitted...
TypeError: 'str' object does not support item assignment

>>> S = 'z' + S[1:]			# But we can run expressions to make new objects
>>> S 
'zpam'
```

```
>>> S = 'shrubbery'
>>> L = list(S)					# Expand to a list: [...]
>>> L
['s', 'h', 'r', 'u', 'b', 'b', 'e', 'r', 'y']
>>> L[1] = 'c'					# Change it in place 
>>> ''.join(L) 					# Join with empty delimiter
'scrubbery'

>>> B = bytearray(b'spam')		# A bytes/list hybrid (ahead)
>>> B.extend(b'eggs')			# 'b' needed in 3.X, not 2.X 
>>> B 							# B[i] = ord(c) works here too
bytearray(b'spameggs')
>>> B.decode() 					# Translate to normal string
'spameggs'
```

The bytearray supports in-place changes for text, but only for text whose characters are all at most 8-bits wide (e.g., ASCII). All other strings are still immutable—bytear ray is a distinct hybrid of immutable bytes strings (whose b'...' syntax is required in 3.X and optional in 2.X) and mutable lists (coded and displayed in [])

### 单引号 Single quotes:

你可以使用单引号来指定字符串，例如 `'将我这样框进来'` 或 `'Quote me on this'` 。

所有引号内的空间，诸如空格与制表符，都将按原样保留。

```
>>> 'knight"s', "knight's" 
('knight"s', "knight's")
```

the comma is important here. Without it, Python automatically concatenates adjacent string literals in any expression

```
>>> title = "Meaning " 'of' " Life"		# Implicit concatenation
>>> title 
'Meaning of Life'
```

### 双引号 Double quotes:

被双引号包括的字符串和被单引号括起的字符串, 其工作机制完全相同。

例如 `"你的名字是？"` 或 `"What's your name?"` 。

```
>>> "What's your name?"
"What's your name?"
>>> 'the "book" is white'
'the "book" is white'
```

### 三引号 Triple quotes:

三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。

三引号的语法是一对连续的单引号`'''`或者双引号`"""`（通常都是成对的用）。

Triple-quoted strings are useful anytime you need multiline text in your program; for example, to embed multiline error messages or HTML, XML, or JSON code in your Python source code files.

你可以在三引号之间自由地使用单引号与双引号。来看看这个例子：

```python
'''这是一段多行字符串。这是它的第一行。
This is the second line.
"What's your name?," I asked.
He said "Bond, James Bond."
'''
```

三重引号字符串常用于文档字符串，当出现在文件的特定地点，被当做注释一样的字符串常量

> Triple-quoted strings are also commonly used for documentation strings, which are string literals that are taken as comments when they appear at specific points in your file

```
X = 1 
""" 
import os 			# Disable this code temporarily
print(os.getcwd()) 
""" 
Y = 2
```

### 转义字符 Escape 

在字符串中，有时需要输入一些特殊的符号，但是，某些符号不能直接输出，就需要用转义符。所谓转义，就是不采用符号本来的含义，而采用另外一含义了。

```
>>> 'What\'s your name?'
"What's your name?"
```

下面表格中列出常用的转义符：

| 转义字符 Escape  | 描述 Meaning                               |
| ------------ | ---------------------------------------- |
| `\newline`   | (在行尾时) 续行符 Ignored (continuation line)   |
| `\\`         | 反斜杠符号 (保留 `\`)                           |
| `\'`         | 单引号 (保留 `'`)                             |
| `\"`         | 双引号 (保留 `"`)                             |
| `\a`         | 响铃                                       |
| `\b`         | 退格(Backspace)                            |
| \e           | 转义                                       |
| `\0`         | 空 Null: binary 0 character (doesn’t end string) |
| `\n`         | 换行 Newline (linefeed)                    |
| `\v`         | 纵向制表符                                    |
| `\t`         | 横向制表符                                    |
| `\r`         | 回车 Carriage return                       |
| `\f`         | 换页 Formfeed                              |
| `\oyy`       | 八进制数，yy代表的字符，Character with octal value ooo (up to 3 digits) |
| `\xyy`       | 十六进制数，yy代表的字符，Character with hex value hh (exactly 2 digits) |
| `\other`     | 其它的字符以普通格式输出 Not an escape (keeps both \ and other) |
| `\N{ id }`   | Unicode database ID                      |
| `\uhhhh`     | Unicode character with 16-bit hex value  |
| `\Uhhhhhhhh` | Unicode character with 32-bit hex value  |
| `\other`     | Not an escape (keeps both \ and other)   |

### 原始字符串 Raw strings

如果你需要指定一些未经过特殊处理的字符串，比如转义序列，那么你需要在字符串前增加 `r` 或 `R` 来指定一个 _原始（Raw）_ 字符串。由r开头引起的字符串，就是原始字符串，在里面放任何字符都表示该字符的原始含义。下面是一个例子：

```
>>> r"Newlines are indicated by \n"
'Newlines are indicated by \\n'
```

> **针对正则表达式用户的提示**
>
> 在处理正则表达式时应全程使用原始字符串。否则，将会有大量 Backwhacking 需要处理。举例说明的话，反向引用可以通过 `'\\1'` 或 `r'\1' ` 来实现。

这种方法在做网站设置网站目录结构的时候非常有用。使用了原始字符串，就不需要转义了。

一个raw字符串不能以奇数个反斜杠结尾，因为反斜杠会转义后续引用的字符

### 字符串运算符

A variable is created when you assign it a value, may be assigned any type of object, and is replaced with its value when it shows up in an expression. It must also have been previously assigned by the time you use its value.

Common string literals and operations:

```
Operation						Interpretation

S = '' 							Empty string
S = "spam's" 					Double quotes, same as single
S = 's\np\ta\x00m' 				Escape sequences
S = """...multiline...""" 		Triple-quoted block strings
S = r'\temp\spam' 				Raw strings (no escapes)
B = b'sp\xc4m' 					Byte strings in 2.6, 2.7, and 3.X
U = u'sp\u00c4m' 				Unicode strings in 2.X and 3.3+
S1 + S2 						Concatenate, repeat
S * 3 
S[i] 							Index, slice, length
S[i:j] 
len(S) 
"a %s parrot" % kind 			String formatting expression
"a {0} parrot".format(kind)		String formatting method in 2.6, 2.7, and 3.X
S.find('pa')					String methods (see ahead for all 43): search,
S.rstrip()						remove whitespace,
S.replace('pa', 'xx')			replacement,
S.split(',')					split on delimiter,
S.isdigit()						content test,
S.lower()						case conversion,
S.endswith('spam') 				end test,
'spam'.join(strlist)			delimiter join,
S.encode('latin-1')				Unicode encoding,
B.decode('utf8') 				Unicode decoding, etc.
for x in S: print(x) 			Iteration, membership
'spam' in S 
[c * 2 for c in S] 
map(ord, S) 
re.match('sp(.*)am', line)		Pattern matching: library module
```

下表实例变量 a 值为字符串 "Hello"，b 变量值为 "Python"：

| 操作符    | 描述                                       | 实例                                |
| ------ | ---------------------------------------- | --------------------------------- |
| +      | 字符串连接                                    | >>>a + b'HelloPython'             |
| *      | 重复输出字符串                                  | >>>a * 2'HelloHello'              |
| []     | 通过索引获取字符串中字符                             | >>>a[1]'e'                        |
| [ : ]  | 截取字符串中的一部分                               | >>>a[1:4]'ell'                    |
| in     | 成员运算符 - 如果字符串中包含给定的字符返回 True             | >>>"H" in aTrue                   |
| not in | 成员运算符 - 如果字符串中不包含给定的字符返回 True            | >>>"M" not in aTrue               |
| r/R    | 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母"r"（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 | >>>print r'\n'\n>>> print R'\n'\n |
| %      | 格式字符串                                    | 见格式化                              |

### Indexing and Slicing：

**Indexing (S[i]) fetches components at offsets:**

- The first item is at offset 0.


- Negative indexes mean to count backward from the end or right.


- S[0] fetches the first item.


- S[−2] fetches the second item from the end (like S[len(S)−2]).

**Slicing (S[i:j]) extracts contiguous sections of sequences:**

- The upper bound is noninclusive.


-  Slice boundaries default to 0 and the sequence length, if omitted.


- S[1:3] fetches items at offsets 1 up to but not including 3.


- S[1:] fetches items at offset 1 through the end (the sequence length).


- S[:3] fetches items at offset 0 up to but not including 3.


- S[:−1] fetches items at offset 0 up to but not including the last item.


- S[:] fetches items at offsets 0 through the end—making a top-level copy of S.

**Extended slicing (S[i:j:k]) accepts a step (or stride) k, which defaults to +1:**

- Allows for skipping items and reversing order—see the next section.

  X[I:J:K], which means “extract all the items in X, from offset I through J−1, by K.”The third limit, K, defaults to +1, which is why normally all items in a slice are extracted from left to right. 

```
>>> 'spam'[1:3] 			# Slicing syntax
'pa'
>>> 'spam'[slice(1, 3)] 	# Slice objects with index syntax + object
'pa'
>>> 'spam'[::-1] 
'maps'
>>> 'spam'[slice(None, None, −1)] 
'maps'
```

![Slicing](img/Slicing.jpg)

> The basics of slicing are straightforward. When you index a sequence object such as a string on a pair of offsets separated by a colon, Python returns a new object containing the contiguous section identified by the offset pair. The left offset is taken to be the lower bound (inclusive), and the right is the upper bound (noninclusive). That is, Python fetches all items from the lower bound up to but not including the upper bound, and returns a new object containing the fetched items. If omitted, the left and right bounds default to 0 and the length of the object you are slicing, respectively.



```
>>> S = 'Spam'		# Make a 4-character string, and assign it to a name 
>>> len(S) 			# Length
4		
>>> S[0] 			# The first item in S, indexing by zero-based position
'S'
>>> S[1] 			# The second item from the left
'p'
>>> S[-1] 			# The last item from the end in S
'm'
>>> S[len(S)-1] 	# Negative indexing, the hard way
'm'					# we can use an arbitrary expression in the square brackets.
					# anywhere that Python expects a value, we can use a literal, a variable, or any expression we wish. Python’s syntax is completely general this way.

>>> S[-2] 			# The second-to-last item from the end
'a'
>>> S 				# A 4-character string 
'Spam'
>>> S[1:3] 			# Slice of S from offsets 1 through 2 (not 3)
'pa'

# In a slice, the left bound defaults to zero, and the right bound defaults to the length of the sequence being sliced. This leads to some common usage variations:

>>> S[1:] 			# Everything past the first (1:len(S)) 
'pam'
>>> S[0:3] 			# Everything but the last
'Spa'
>>> S[:3] 			# Same as S[0:3]
'Spa'
>>> S[:-1] 			# Everything but the last again, but simpler (0:-1)
'Spa'
>>> S[:] 			# All of S as a top-level copy (0:len(S))
'Spam'
>>> S + 'xyz' 		# Concatenation 
'Spamxyz'
>>> S 				# S is unchanged 
'Spam'
>>> S * 8 			# Repetition 
'SpamSpamSpamSpamSpamSpamSpamSpam'
```



### 变量和字符串

**变量无类型，对象有类型**

在对字符串类型的对象，能够通过赋值语句，将对象与某个标签（变量）关联起来。

```
>>> b = "hello,world"
>>> b
'hello,world'
>>> print(b)
hello,world

>>> type(b)
<class 'str'>
```

其本质含义是变量b相当于一个标签，贴在了对象"hello,world"上面。



### 拼接字符串

用`+`拼接起来的两个对象，必须是同一种类型的。

```
>>> "py" + "thon"
'python'
```



## 字符串转换工具 String Conversion

### str()

用`str()`实现将整数对象转换为字符串对象。

```
>>> a = "250"
>>> type(a)
<class 'str'>
>>> b = int(a)
>>> b
250
>>> type(b)
<class 'int'>
```

### repr()

这里repr()是一个函数，其实就是反引号的替代品，它能够把结果字符串转化为合法的python表达式。

```
>>> type(b)
<class 'int'>
>>> b = "free"
>>> a = 1989
>>> print(b+repr(a))
free1989
```

### ``(python2)



```
>>> a = 12
>>> `a`
'12'
```

注意，`` 是反引号，不是单引号，就是键盘中通常在数字1左边的那个，在英文半角状态下输入的符号。这种方法，在编程实践中比较少应用，特别是在python3中，已经把这种方式弃绝了。







## Python对Unicode的支持

在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：

```
>>> print('包含中文的str')
包含中文的str
```



### Unicode 字符串

以Unicode表示的字符串用`u'...'`表示，引号前小写的"u"表示这里创建的是一个 Unicode 字符串。比如：

```
>>> print(u'中文')
中文
>>> u'中'    #python3
'中'
>>> u'中'	#python2
u'\u4e2d'
```

写`u'中'`和`u'\u4e2d'`是一样的，`\u`后面是十六进制的Unicode码。

如果你想加入一个特殊字符，可以使用 Python 的 Unicode-Escape 编码。

```
>>> print(u'Hello\u0020World !')    #python3
Hello World !
```

被替换的 \u0020 标识表示在给定位置插入编码值为 0x0020 的 Unicode 字符（空格符）。

字符串`'xxx'`虽然是ASCII编码，但也可以看成是UTF-8编码，而`u'xxx'`则只能是Unicode编码。







### ord()和chr()函数

对于单个字符的编码，Python提供了

`ord()`函数 (转换为对应的ASCII码，函数实际返回的是这个字符在内存中对应的字符的二进制值) 获取字符的整数表示，

`chr()`函数(获取ASCII码并将其转化为对应的字符)把编码转换为对应的字符：

```
>>> ord('A')
65
>>> ord('中')
20013
>>> chr(66)
'B'
>>> chr(25991)
'文'
```

如果知道字符的整数编码，还可以用十六进制这么写`str`：

```
>>> '\u4e2d\u6587'
'中文'
```

两种写法完全是等价的。

### bytes `b`前缀

由于Python的字符串类型是`str`，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把`str`变为以字节为单位的`bytes`。

Python对`bytes`类型的数据用带`b`前缀的单引号或双引号表示：

```
x = b'ABC'
```

要注意区分`'ABC'`和`b'ABC'`，前者是`str`，后者虽然内容显示得和前者一样，但`bytes`的每个字符都只占用一个字节。







### encode()

以Unicode表示的`str`通过`encode()`方法可以编码为指定的`bytes`，例如：

```
>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
>>> '中文'.encode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
```

纯英文的`str`可以用`ASCII`编码为`bytes`，内容是一样的，含有中文的`str`可以用`UTF-8`编码为`bytes`。含有中文的`str`无法用`ASCII`编码，因为中文编码的范围超过了`ASCII`编码的范围，Python会报错。

在`bytes`中，无法显示为ASCII字符的字节，用`\x##`显示。

### encode() (python2)

把`u'xxx'`转换为UTF-8编码的`'xxx'`用`encode('utf-8')`方法：

```
>>> u'ABC'.encode('utf-8')
'ABC'
>>> u'中文'.encode('utf-8')
'\xe4\xb8\xad\xe6\x96\x87'
```

英文字符转换后表示的UTF-8的值和Unicode值相等（但占用的存储空间不同），而中文字符转换后1个Unicode字符将变为3个UTF-8字符，你看到的`\xe4`就是其中一个字节，因为它的值是`228`，没有对应的字母可以显示，所以以十六进制显示字节的数值。`len()`函数可以返回字符串的长度：

```
>>> len(u'ABC')
3
>>> len('ABC')
3
>>> len(u'中文')
2
>>> len('\xe4\xb8\xad\xe6\x96\x87')
6
```



### decode()

如果我们从网络或磁盘上读取了字节流，那么读到的数据就是`bytes`。要把`bytes`变为`str`，就需要用`decode()`方法：

```
>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
```

要计算`str`包含多少个字符，可以用`len()`函数：

```
>>> len('ABC')
3
>>> len('中文')
2
```

`len()`函数计算的是`str`的字符数，如果换成`bytes`，`len()`函数就计算字节数：

```
>>> len(b'ABC')
3
>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
6
>>> len('中文'.encode('utf-8'))
6
```

可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

### decode() (python2)

把UTF-8编码表示的字符串`'xxx'`转换为Unicode字符串`u'xxx'`用`decode('utf-8')`方法：

```
>>> 'abc'.decode('utf-8')
u'abc'
>>> '\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
u'\u4e2d\u6587'
>>> print '\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
中文
```

在操作字符串时，我们经常遇到`str`和`bytes`的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对`str`和`bytes`进行转换。



### Python源代码

由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
```

> 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；
>
> 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

如果`.py`文件本身使用UTF-8编码，并且也申明了`# -*- coding: utf-8 -*-`，打开命令提示符测试就可以正常显示中文：

### 使用Notepad++进行编辑

如果你使用Notepad++进行编辑，除了要加上`# -*- coding: utf-8 -*-`外，中文字符串必须是Unicode字符串

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-

print(u"中文")
```

> 申明了UTF-8编码并不意味着你的`.py`文件就是UTF-8编码的，必须并且要确保Notepad++正在使用UTF-8 without BOM编码(Notepad++中，在Encoding中设置)













## 格式化

### “格式化字符串”用`%`实现

在Python中，采用的格式化方式和C语言是一致的，“格式化字符串”用`%`实现，举例如下：

```
>>> 'Hello, %s' % 'world'
'Hello, world'
>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'
```

`%`运算符就是用来格式化字符串的。在字符串内部，`%s`表示用字符串替换，`%d`表示用整数替换，有几个`%?`占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个`%?`，括号可以省略。



不同的占位符，会表示那个位置应该被不同类型的对象填充。常见的占位符有：

| 占位符  | 说明                 |
| ---- | ------------------ |
| %s   | 字符串(采用str()的显示)    |
| %r   | 字符串(采用repr()的显示)   |
| %c   | 单个字符               |
| %b   | 二进制整数              |
| %d   | 十进制整数              |
| %i   | 十进制整数              |
| %o   | 八进制整数              |
| %x   | 十六进制整数             |
| %e   | 指数 (基底写为e)         |
| %E   | 指数 (基底写为E)         |
| %f   | 浮点数                |
| %F   | 浮点数，与上相同           |
| %g   | 指数(e)或浮点数 (根据显示长度) |
| %G   | 指数(E)或浮点数 (根据显示长度) |
| %%   | 字符"%"              |



其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：

```
>>> '%2d-%02d' % (3, 1)
' 3-01'
>>> '%.2f' % 3.1415926
'3.14'
```

如果你不太确定应该用什么，`%s`永远起作用，它会把任何数据类型转换为字符串：

```
>>> 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'

```

有些时候，字符串里面的`%`是一个普通字符怎么办？这个时候就需要转义，用`%%`来表示一个`%`：

```
>>> 'growth rate: %d %%' % 7
'growth rate: 7 %'
```

还有一些辅助符号，如下表所示：

| 辅助符号 | 说明                                       |
| ---- | ---------------------------------------- |
| *    | 定义宽度或者小数点精度                              |
| -    | 用做左对齐                                    |
| +    | 在正数前面显示加号(+)                             |
| <sp> | 在正数前面显示空格                                |
| #    | 在八进制数前面显示零(0)，在十六进制前面显示“0x”或者“0X”（取决于用的是“x”还是“X”） |
| 0    | 显示的数字前面填充“0”而不是默认的空格                     |
| m.n  | m 是显示的最小总宽度，n 是小数点后的位数（如果可用的话）           |

注意：辅助符号要在百分号(%)和格式化符号之间。

```
>>> Num1 = 108
>>> print("%#X" % Num1)
0X6C
>>> Num2 = 234.567890
>>> print("%.2f" % Num2)
234.57
```

注意，上面的例子中，没有实现四舍五入的操作，貌似只是截取。就请回头找一找本教程中关于十进制与二进制数转换的讲述。



### `string.format()`的格式化方法

python非常提倡的`string.format()`的格式化方法:

```
>>> s1 = "I like {0}".format("python")
>>> s1
'I like python'
>>> s2 = "Suzhou is more than {0} years. {1} lives in here.".format(2500, "jim") 
>>> s2
'Suzhou is more than 2500 years. jim lives in here.'
```

其中`{索引值}`作为占位符，只需要将对应的东西，按照顺序在format后面的括号中排列好，分别对应占位符`{}`即可。

```
>>> print "Suzhou is more than {year} years. {name} lives in here.".format(year=2500, name="jim") 
Suzhou is more than 2500 years. jim lives in here.
```

Python 中 `format` 方法所做的事情便是将每个参数值替换至格式所在的位置。这之中可以有更详细的格式，例如：

```python
# 对于浮点数 '0.333' 保留小数点(.)后三位
print('{0:.3f}'.format(1.0/3))
# 使用下划线填充文本，并保持文字处于中间位置
# 使用 (^) 定义 '___hello___'字符串长度为 11
print('{0:_^11}'.format('hello'))
# 基于关键词输出 'Swaroop wrote A Byte of Python'  
print('{name} wrote {book}'.format(name='Swaroop', book='A Byte of Python'))
```

输出：

```
0.333
___hello___
Swaroop wrote A Byte of Python
```

由于我们正在讨论格式问题，就要注意 `print` 总是会以一个不可见的“新一行”字符（`\n`）结尾，因此重复调用 `print`将会在相互独立的一行中分别打印。为防止打印过程中出现这一换行符，你可以通过 `end` 指定其应以空白结尾：

```python
print('a', end='')
print('b', end='')
```

输出结果如下：

```
ab
```

或者你通过 `end` 指定以空格结尾：

```python
print('a', end=' ')
print('b', end=' ')
print('c')
```

输出结果如下：

```
a b c
```

### 



### 字典格式化

还有一种格式化的方法，被称为“字典格式化”

```
>>> lang = "python"
>>> print("I love %(program)s"%{"program":lang})
I love python
```



## bytes

#### class bytes(object)

```
Help on class bytes in module builtins:

class bytes(object)
 |  bytes(iterable_of_ints) -> bytes
 |  bytes(string, encoding[, errors]) -> bytes
 |  bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
 |  bytes(int) -> bytes object of size given by the parameter initialized with null bytes
 |  bytes() -> empty bytes object
 |  
 |  Construct an immutable array of bytes from:
 |    - an iterable yielding integers in range(256)
 |    - a text string encoded using the specified encoding
 |    - any object implementing the buffer API.
 |    - an integer
 |  
 |  Methods defined here:
 |  
 |  __add__(self, value, /)
 |      Return self+value.
 |  
 |  __contains__(self, key, /)
 |      Return key in self.
 |  
 |  __eq__(self, value, /)
 |      Return self==value.
 |  
 |  __ge__(self, value, /)
 |      Return self>=value.
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __getitem__(self, key, /)
 |      Return self[key].
 |  
 |  __getnewargs__(...)
 |  
 |  __gt__(self, value, /)
 |      Return self>value.
 |  
 |  __hash__(self, /)
 |      Return hash(self).
 |  
 |  __iter__(self, /)
 |      Implement iter(self).
 |  
 |  __le__(self, value, /)
 |      Return self<=value.
 |  
 |  __len__(self, /)
 |      Return len(self).
 |  
 |  __lt__(self, value, /)
 |      Return self<value.
 |  
 |  __mul__(self, value, /)
 |      Return self*value.n
 |  
 |  __ne__(self, value, /)
 |      Return self!=value.
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __rmul__(self, value, /)
 |      Return self*value.
 |  
 |  __sizeof__(...)
 |      B.__sizeof__() -> size of B in memory, in bytes
 |  
 |  __str__(self, /)
 |      Return str(self).
 |  
 |  capitalize(...)
 |      B.capitalize() -> copy of B
 |      
 |      Return a copy of B with only its first character capitalized (ASCII)
 |      and the rest lower-cased.
 |  
 |  center(...)
 |      B.center(width[, fillchar]) -> copy of B
 |      
 |      Return B centered in a string of length width.  Padding is
 |      done using the specified fill character (default is a space).
 |  
 |  count(...)
 |      B.count(sub[, start[, end]]) -> int
 |      
 |      Return the number of non-overlapping occurrences of substring sub in
 |      string B[start:end].  Optional arguments start and end are interpreted
 |      as in slice notation.
 |  
 |  decode(...)
 |      B.decode(encoding='utf-8', errors='strict') -> str
 |      
 |      Decode B using the codec registered for encoding. Default encoding
 |      is 'utf-8'. errors may be given to set a different error
 |      handling scheme.  Default is 'strict' meaning that encoding errors raise
 |      a UnicodeDecodeError.  Other possible values are 'ignore' and 'replace'
 |      as well as any other name registerd with codecs.register_error that is
 |      able to handle UnicodeDecodeErrors.
 |  
 |  endswith(...)
 |      B.endswith(suffix[, start[, end]]) -> bool
 |      
 |      Return True if B ends with the specified suffix, False otherwise.
 |      With optional start, test B beginning at that position.
 |      With optional end, stop comparing B at that position.
 |      suffix can also be a tuple of bytes to try.
 |  
 |  expandtabs(...)
 |      B.expandtabs(tabsize=8) -> copy of B
 |      
 |      Return a copy of B where all tab characters are expanded using spaces.
 |      If tabsize is not given, a tab size of 8 characters is assumed.
 |  
 |  find(...)
 |      B.find(sub[, start[, end]]) -> int
 |      
 |      Return the lowest index in B where substring sub is found,
 |      such that sub is contained within B[start:end].  Optional
 |      arguments start and end are interpreted as in slice notation.
 |      
 |      Return -1 on failure.
 |  
 |  fromhex(...) from builtins.type
 |      bytes.fromhex(string) -> bytes
 |      
 |      Create a bytes object from a string of hexadecimal numbers.
 |      Spaces between two numbers are accepted.
 |      Example: bytes.fromhex('B9 01EF') -> b'\xb9\x01\xef'.
 |  
 |  index(...)
 |      B.index(sub[, start[, end]]) -> int
 |      
 |      Like B.find() but raise ValueError when the substring is not found.
 |  
 |  isalnum(...)
 |      B.isalnum() -> bool
 |      
 |      Return True if all characters in B are alphanumeric
 |      and there is at least one character in B, False otherwise.
 |  
 |  isalpha(...)
 |      B.isalpha() -> bool
 |      
 |      Return True if all characters in B are alphabetic
 |      and there is at least one character in B, False otherwise.
 |  
 |  isdigit(...)
 |      B.isdigit() -> bool
 |      
 |      Return True if all characters in B are digits
 |      and there is at least one character in B, False otherwise.
 |  
 |  islower(...)
 |      B.islower() -> bool
 |      
 |      Return True if all cased characters in B are lowercase and there is
 |      at least one cased character in B, False otherwise.
 |  
 |  isspace(...)
 |      B.isspace() -> bool
 |      
 |      Return True if all characters in B are whitespace
 |      and there is at least one character in B, False otherwise.
 |  
 |  istitle(...)
 |      B.istitle() -> bool
 |      
 |      Return True if B is a titlecased string and there is at least one
 |      character in B, i.e. uppercase characters may only follow uncased
 |      characters and lowercase characters only cased ones. Return False
 |      otherwise.
 |  
 |  isupper(...)
 |      B.isupper() -> bool
 |      
 |      Return True if all cased characters in B are uppercase and there is
 |      at least one cased character in B, False otherwise.
 |  
 |  join(...)
 |      B.join(iterable_of_bytes) -> bytes
 |      
 |      Concatenate any number of bytes objects, with B in between each pair.
 |      Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.
 |  
 |  ljust(...)
 |      B.ljust(width[, fillchar]) -> copy of B
 |      
 |      Return B left justified in a string of length width. Padding is
 |      done using the specified fill character (default is a space).
 |  
 |  lower(...)
 |      B.lower() -> copy of B
 |      
 |      Return a copy of B with all ASCII characters converted to lowercase.
 |  
 |  lstrip(...)
 |      B.lstrip([bytes]) -> bytes
 |      
 |      Strip leading bytes contained in the argument.
 |      If the argument is omitted, strip leading ASCII whitespace.
 |  
 |  partition(...)
 |      B.partition(sep) -> (head, sep, tail)
 |      
 |      Search for the separator sep in B, and return the part before it,
 |      the separator itself, and the part after it.  If the separator is not
 |      found, returns B and two empty bytes objects.
 |  
 |  replace(...)
 |      B.replace(old, new[, count]) -> bytes
 |      
 |      Return a copy of B with all occurrences of subsection
 |      old replaced by new.  If the optional argument count is
 |      given, only first count occurances are replaced.
 |  
 |  rfind(...)
 |      B.rfind(sub[, start[, end]]) -> int
 |      
 |      Return the highest index in B where substring sub is found,
 |      such that sub is contained within B[start:end].  Optional
 |      arguments start and end are interpreted as in slice notation.
 |      
 |      Return -1 on failure.
 |  
 |  rindex(...)
 |      B.rindex(sub[, start[, end]]) -> int
 |      
 |      Like B.rfind() but raise ValueError when the substring is not found.
 |  
 |  rjust(...)
 |      B.rjust(width[, fillchar]) -> copy of B
 |      
 |      Return B right justified in a string of length width. Padding is
 |      done using the specified fill character (default is a space)
 |  
 |  rpartition(...)
 |      B.rpartition(sep) -> (head, sep, tail)
 |      
 |      Search for the separator sep in B, starting at the end of B,
 |      and return the part before it, the separator itself, and the
 |      part after it.  If the separator is not found, returns two empty
 |      bytes objects and B.
 |  
 |  rsplit(...)
 |      B.rsplit(sep=None, maxsplit=-1) -> list of bytes
 |      
 |      Return a list of the sections in B, using sep as the delimiter,
 |      starting at the end of B and working to the front.
 |      If sep is not given, B is split on ASCII whitespace characters
 |      (space, tab, return, newline, formfeed, vertical tab).
 |      If maxsplit is given, at most maxsplit splits are done.
 |  
 |  rstrip(...)
 |      B.rstrip([bytes]) -> bytes
 |      
 |      Strip trailing bytes contained in the argument.
 |      If the argument is omitted, strip trailing ASCII whitespace.
 |  
 |  split(...)
 |      B.split(sep=None, maxsplit=-1) -> list of bytes
 |      
 |      Return a list of the sections in B, using sep as the delimiter.
 |      If sep is not specified or is None, B is split on ASCII whitespace
 |      characters (space, tab, return, newline, formfeed, vertical tab).
 |      If maxsplit is given, at most maxsplit splits are done.
 |  
 |  splitlines(...)
 |      B.splitlines([keepends]) -> list of lines
 |      
 |      Return a list of the lines in B, breaking at line boundaries.
 |      Line breaks are not included in the resulting list unless keepends
 |      is given and true.
 |  
 |  startswith(...)
 |      B.startswith(prefix[, start[, end]]) -> bool
 |      
 |      Return True if B starts with the specified prefix, False otherwise.
 |      With optional start, test B beginning at that position.
 |      With optional end, stop comparing B at that position.
 |      prefix can also be a tuple of bytes to try.
 |  
 |  strip(...)
 |      B.strip([bytes]) -> bytes
 |      
 |      Strip leading and trailing bytes contained in the argument.
 |      If the argument is omitted, strip leading and trailing ASCII whitespace.
 |  
 |  swapcase(...)
 |      B.swapcase() -> copy of B
 |      
 |      Return a copy of B with uppercase ASCII characters converted
 |      to lowercase ASCII and vice versa.
 |  
 |  title(...)
 |      B.title() -> copy of B
 |      
 |      Return a titlecased version of B, i.e. ASCII words start with uppercase
 |      characters, all remaining cased characters have lowercase.
 |  
 |  translate(...)
 |      B.translate(table[, deletechars]) -> bytes
 |      
 |      Return a copy of B, where all characters occurring in the
 |      optional argument deletechars are removed, and the remaining
 |      characters have been mapped through the given translation
 |      table, which must be a bytes object of length 256.
 |  
 |  upper(...)
 |      B.upper() -> copy of B
 |      
 |      Return a copy of B with all ASCII characters converted to uppercase.
 |  
 |  zfill(...)
 |      B.zfill(width) -> copy of B
 |      
 |      Pad a numeric string B with zeros on the left, to fill a field
 |      of the specified width.  B is never truncated.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  maketrans(...)
 |      B.maketrans(frm, to) -> translation table
 |      
 |      Return a translation table (a bytes object of length 256) suitable
 |      for use in the bytes or bytearray translate method where each byte
 |      in frm is mapped to the byte at the same position in to.
 |      The bytes objects frm and to must be of the same length.
```





## python的字符串内建函数

### Method Call Syntax

methods are simply functions that are associated with and act upon particular objects. Technically, they are attributes attached to objects that happen to reference callable functions which always have an implied subject. In finer-grained detail, functions are packages of code, and **method calls combine two operations at once—an attribute fetch and a call:**

> Attribute fetches 
>
> An expression of the form object.attribute means “fetch the value of attribute in object.”

> Call expressions 
>
> An expression of the form function(arguments) means “invoke the code of func tion, passing zero or more comma-separated argument objects to it, and return function’s result value.”

**The method call expression:**

```
object.method(arguments)
```

> is evaluated from left to right—Python will first fetch the method of the object and then call it, passing in both object and the arguments. Or, in plain words, the method call expression means this:
>
> Call method to process object with arguments.
>
> If the method computes a result, it will also come back as the result of the entire method-call expression.
>
> ```
> >>> S = 'spam'
> >>> result = S.find('pa')	# Call the find method to look for 'pa' in string S
> ```
>
> most objects have callable methods, and all are accessed using this same method-call syntax. methods cannot be run (and make little sense) without a subject.



### String method calls

这些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的。

```
>>> help(str)	#查看string模块

>>> dir(str)	#string包内函数列表
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

>>> help(str.title)		#查看string包内title函数功能
```

Python 的字符串常用内建函数如下：

In this table, S is a string object, and optional arguments are enclosed in square brackets.

| 序号   | 方法及描述                                    |
| ---- | ---------------------------------------- |
| 1    | [capitalize()](http://www.runoob.com/python3/python3-string-capitalize.html)    将字符串的第一个字符转换为大写 |
|      | S.casefold()                             |
| 2    | [center(width, fillchar)](http://www.runoob.com/python3/python3-string-center.html)    返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 |
| 3    | [count(str, beg= 0,end=len(string))](http://www.runoob.com/python3/python3-string-count.html)    返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 |
| 4    | [bytes.decode(encoding="utf-8", errors="strict")](http://www.runoob.com/python3/python3-string-decode.html)    Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 |
| 5    | [encode(encoding='UTF-8',errors='strict')](http://www.runoob.com/python3/python3-string-encode.html)    以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' |
| 6    | [endswith(suffix, beg=0, end=len(string))](http://www.runoob.com/python3/python3-string-endswith.html)    检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. |
| 7    | [expandtabs(tabsize=8)](http://www.runoob.com/python3/python3-string-expandtabs.html)    把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 |
| 8    | [find(str, beg=0 end=len(string))](http://www.runoob.com/python3/python3-string-find.html)    检测 str 是否包含在字符串中 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 |
|      | S.format(fmtstr, *args, **kwargs)        |
| 9    | [index(str, beg=0, end=len(string))](http://www.runoob.com/python3/python3-string-index.html)    跟find()方法一样，只不过如果str不在字符串中会报一个异常. |
| 10   | [isalnum()](http://www.runoob.com/python3/python3-string-isalnum.html)    如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False |
| 11   | [isalpha()](http://www.runoob.com/python3/python3-string-isalpha.html)    如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False |
|      | S.isdecimal()                            |
| 40   | [isdecimal()](http://www.runoob.com/python3/python3-string-isdecimal.html)检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 |
| 12   | [isdigit()](http://www.runoob.com/python3/python3-string-isdigit.html)    如果字符串只包含数字则返回 True 否则返回 False.. |
|      | S.isidentifier()                         |
| 13   | [islower()](http://www.runoob.com/python3/python3-string-islower.html)    如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False |
| 14   | [isnumeric()](http://www.runoob.com/python3/python3-string-isnumeric.html)    如果字符串中只包含数字字符，则返回 True，否则返回 False |
|      | S.isprintable()                          |
| 15   | [isspace()](http://www.runoob.com/python3/python3-string-isspace.html)    如果字符串中只包含空格，则返回 True，否则返回 False. |
| 16   | [istitle()](http://www.runoob.com/python3/python3-string-istitle.html)    如果字符串是标题化的(见 title())则返回 True，否则返回 False |
| 17   | [isupper()](http://www.runoob.com/python3/python3-string-isupper.html)    如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False |
| 18   | S.join(iterable)    以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 |
| 19   | [len(string)](http://www.runoob.com/python3/python3-string-len.html)    返回字符串长度 |
| 20   | `S.ljust(width[, fillchar])` 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 |
| 21   | [lower()](http://www.runoob.com/python3/python3-string-lower.html)转换字符串中所有大写字符为小写. |
| 22   | [lstrip()](http://www.runoob.com/python3/python3-string-lstrip.html)截掉字符串左边的空格 |
| 23   | `S.maketrans(x[, y[, z]])` 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 |
| 24   | [max(str)](http://www.runoob.com/python3/python3-string-max.html)返回字符串 str 中最大的字母。 |
| 25   | [min(str)](http://www.runoob.com/python3/python3-string-min.html)返回字符串 str 中最小的字母。 |
|      | `S.partition(sep)`                       |
| 26   | `S.replace(old, new [, count])` 把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 |
| 27   | [rfind(str, beg=0,end=len(string))](http://www.runoob.com/python3/python3-string-rfind.html)类似于 find()函数，不过是从右边开始查找. |
| 28   | [rindex( str, beg=0, end=len(string))](http://www.runoob.com/python3/python3-string-rindex.html)类似于 index()，不过是从右边开始. |
| 29   | `S.rjust(width [, fillchar])` 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 |
|      | `S.rpartition(sep)`                      |
| 31   | split(str="", num=string.count(str))num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 |
| 30   | [rstrip()](http://www.runoob.com/python3/python3-string-rstrip.html)删除字符串字符串末尾的空格. |
|      | `S.split([sep [,maxsplit]])`             |
| 32   | splitlines([keepends\])按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 |
| 33   | [startswith(str, beg=0,end=len(string))](http://www.runoob.com/python3/python3-string-startswith.html)检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 |
| 34   | strip([chars\])在字符串上执行 lstrip()和 rstrip() |
| 35   | [swapcase()](http://www.runoob.com/python3/python3-string-swapcase.html)将字符串中大写转换为小写，小写转换为大写 |
| 36   | [title()](http://www.runoob.com/python3/python3-string-title.html)返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) |
| 37   | [translate(table, deletechars="")](http://www.runoob.com/python3/python3-string-translate.html)根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 |
| 38   | [upper()](http://www.runoob.com/python3/python3-string-upper.html)转换字符串中的小写字母为大写 |
| 39   | [zfill (width)](http://www.runoob.com/python3/python3-string-zfill.html)返回长度为 width 的字符串，原字符串右对齐，前面填充0 |
|      |                                          |





### str.capitalize()

capitalize()将字符串的第一个字母变成大写,其他字母变小写。对于 8 位字节编码需要根据本地环境。

> **capitalize**(...)
>
>     S.capitalize() -> str
>
>     
>
>     Return a capitalized version of S, i.e. make the first character
>
>     have upper case and the rest lower case.

```
>>> "aBCD".capitalize()
'Abcd'
```



### str.casefold()

将字符串转换成小写，Unicode 编码中凡是有对应的小写形式的，都会转换。

> **casefold**(...)
>
> ​    S.casefold() -> str
>
> ​    
>
> ​    Return a version of S suitable for caseless comparisons.

```
>>> "aBCD".casefold()
'abcd'
```



### str.center()

 center() 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格。

- width -- 字符串的总宽度。
- fillchar -- 填充字符。

> **center**(...)
>
> ​    S.center(width[, fillchar]) -> str
>
> ​    
>
> ​    Return S centered in a string of length width. Padding is
>
> ​    done using the specified fill character (default is a space)

```
>>> "aB C De".center(11,"o")
'ooaB C Deoo'
```



### str.count()

count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。

```
str.count(sub, start= 0,end=len(string))
```

- sub -- 搜索的子字符串
- start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。
- end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。

该方法返回子字符串在字符串中出现的次数。

> **count**(...)
>
>     S.count(sub[, start[, end]]) -> int
>
>     
>
>     Return the number of non-overlapping occurrences of substring sub in
>
>     string S[start:end].  Optional arguments start and end are
>
>     interpreted as in slice notation.

```
>>> "apple".count("p")
2
>>> "apple".count("a",0,4)
1
```





### str.encode()

encode() 方法以指定的编码格式编码字符串。errors参数可以指定不同的错误处理方案。

```
str.encode(encoding='UTF-8',errors='strict')
```

- encoding -- 要使用的编码，如: UTF-8。
- errors -- 设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个UnicodeError。 其他可能得值有 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过 codecs.register_error() 注册的任何值。

该方法返回编码后的字符串，它是一个 bytes 对象。

> ```
> Help on method_descriptor:
>
> encode(...)
>     S.encode(encoding='utf-8', errors='strict') -> bytes
>     
>     Encode S using the codec registered for encoding. Default encoding
>     is 'utf-8'. errors may be given to set a different error
>     handling scheme. Default is 'strict' meaning that encoding errors raise
>     a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
>     'xmlcharrefreplace' as well as any other name registered with
>     codecs.register_error that can handle UnicodeEncodeErrors.
> ```

```
>>> "你好".encode("UTF-8")
b'\xe4\xbd\xa0\xe5\xa5\xbd'
>>> "你好".encode("GBK")
b'\xc4\xe3\xba\xc3'
>>> 'ABC'.encode('ascii')
b'ABC'

>>> "你好".encode("utf-8","strict")
b'\xe4\xbd\xa0\xe5\xa5\xbd'
>>> "你好".encode("gbk","strict")
b'\xc4\xe3\xba\xc3'
```



### bytes.decode()

decode() 方法以指定的编码格式解码 bytes 对象。默认编码为 'utf-8'。

```
bytes.decode(encoding="utf-8", errors="strict")
```

- encoding -- 要使用的编码，如"UTF-8"。
- errors -- 设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个UnicodeError。 其他可能得值有 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过 codecs.register_error() 注册的任何值。

该方法返回解码后的字符串。

> ```
> Help on method_descriptor:
>
> decode(...)
>     B.decode(encoding='utf-8', errors='strict') -> str
>     
>     Decode B using the codec registered for encoding. Default encoding
>     is 'utf-8'. errors may be given to set a different error
>     handling scheme.  Default is 'strict' meaning that encoding errors raise
>     a UnicodeDecodeError.  Other possible values are 'ignore' and 'replace'
>     as well as any other name registerd with codecs.register_error that is
>     able to handle UnicodeDecodeErrors.
> ```

```
>>> b'ABC'.decode('ascii')
'ABC'				# <class 'str'>
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
```







### str.endswith()

endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数"start"与"end"为检索字符串的开始与结束位置。

```
str.endswith(suffix[, start[, end]])
```

- suffix -- 该参数可以是一个字符串或者是一个元素。
- start -- 字符串中的开始位置。
- end -- 字符中结束位置。

如果字符串含有指定的后缀返回True，否则返回False。

> **endswith**(...)
>
>     S.endswith(suffix[, start[, end]]) -> bool
>
>     
>
>     Return True if S ends with the specified suffix, False otherwise.
>
>     With optional start, test S beginning at that position.
>
>     With optional end, stop comparing S at that position.
>
>     suffix can also be a tuple of strings to try.

```
>>> "apple".endswith("le")
True
>>> "apple".endswith("le",2)
True
>>> "apple".endswith("le",0,3)
False
```



### str.expandtabs()

expandtabs() 方法把字符串中的 tab 符号('\t')转为空格，tab 符号('\t')默认的空格数是 8。

```
str.expandtabs(tabsize=8)
```

- tabsize -- 指定转换字符串中的 tab 符号('\t')转为空格的字符数。

该方法返回字符串中的 tab 符号('\t')转为空格后生成的新字符串。

> **expandtabs**(...)
>
>     S.expandtabs(tabsize=8) -> str
>
>     
>
>     Return a copy of S where all tab characters are expanded using spaces.
>
>     If tabsize is not given, a tab size of 8 characters is assumed.

```
>>> "good\tboy".expandtabs()
'good    boy'
>>> "good\tboy".expandtabs(2)
'good  boy'
```



### str.find()

find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。

```
str.find(str, beg=0, end=len(string))
```

- str -- 指定检索的字符串
- beg -- 开始索引，默认为0。
- end -- 结束索引，默认为字符串的长度。

如果包含子字符串返回开始的索引值，否则返回-1。

> **find**(...)
>
>     S.find(sub[, start[, end]]) -> int
>
>     
>
>     Return the lowest index in S where substring sub is found,
>
>     such that sub is contained within S[start:end].  Optional
>
>     arguments start and end are interpreted as in slice notation.
>
>     
>
>     Return -1 on failure.

```
>>> "apple".find("pl")
2
>>> "apple".find("pl",1)
2
>>> "apple".find("pl",3)
-1
>>> "apple".find("pl",1,4)
2
```



### str.format()

https://docs.python.org/3/library/string.html#module-string



> **format**(...)
>
>     S.format(*args, **kwargs) -> str
>
>     
>
>     Return a formatted version of S, using substitutions from args and kwargs.
>
>     The substitutions are identified by braces ('{' and '}').

**Format examples:**

Accessing arguments by position:

```
>>> '{0}, {1}, {2}'.format('a', 'b', 'c')
'a, b, c'
>>> '{}, {}, {}'.format('a', 'b', 'c')  # 3.1+ only
'a, b, c'
>>> '{2}, {1}, {0}'.format('a', 'b', 'c')
'c, b, a'
>>> '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence
'c, b, a'
>>> '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be repeated
'abracadabra'
```

Accessing arguments by name:

```
>>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')
'Coordinates: 37.24N, -115.81W'
>>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'}
>>> 'Coordinates: {latitude}, {longitude}'.format(**coord)
'Coordinates: 37.24N, -115.81W'
```

Accessing arguments’ attributes:

```
>>> c = 3-5j
>>> ('The complex number {0} is formed from the real part {0.real} '
...  'and the imaginary part {0.imag}.').format(c)
'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'
>>> class Point:
...     def __init__(self, x, y):
...         self.x, self.y = x, y
...     def __str__(self):
...         return 'Point({self.x}, {self.y})'.format(self=self)
...
>>> str(Point(4, 2))
'Point(4, 2)'
```

Accessing arguments’ items:

```
>>> coord = (3, 5)
>>> 'X: {0[0]};  Y: {0[1]}'.format(coord)
'X: 3;  Y: 5'
```

Replacing `%s` and `%r`:

```
>>> "repr() shows quotes: {!r}; str() doesn't: {!s}".format('test1', 'test2')
"repr() shows quotes: 'test1'; str() doesn't: test2"
```

Aligning the text and specifying a width:

```
>>> '{:<30}'.format('left aligned')
'left aligned                  '
>>> '{:>30}'.format('right aligned')
'                 right aligned'
>>> '{:^30}'.format('centered')
'           centered           '
>>> '{:*^30}'.format('centered')  # use '*' as a fill char
'***********centered***********'

```

Replacing `%+f`, `%-f`, and `% f` and specifying a sign:

```
>>> '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always
'+3.140000; -3.140000'
>>> '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive numbers
' 3.140000; -3.140000'
>>> '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as '{:f}; {:f}'
'3.140000; -3.140000'
```

Replacing `%x` and `%o` and converting the value to different bases:

```
>>> # format also supports binary numbers
>>> "int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}".format(42)
'int: 42;  hex: 2a;  oct: 52;  bin: 101010'
>>> # with 0x, 0o, or 0b as prefix:
>>> "int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}".format(42)
'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'
```

Using the comma as a thousands separator:

```
>>> '{:,}'.format(1234567890)
'1,234,567,890'
```

Expressing a percentage:

```
>>> points = 19
>>> total = 22
>>> 'Correct answers: {:.2%}'.format(points/total)
'Correct answers: 86.36%'
```

Using type-specific formatting:

```
>>> import datetime
>>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)
>>> '{:%Y-%m-%d %H:%M:%S}'.format(d)
'2010-07-04 12:15:58'
```

Nesting arguments and more complex examples:

```
>>> for align, text in zip('<^>', ['left', 'center', 'right']):
...     '{0:{fill}{align}16}'.format(text, fill=align, align=align)
...
'left<<<<<<<<<<<<'
'^^^^^center^^^^^'
'>>>>>>>>>>>right'
>>>
>>> octets = [192, 168, 0, 1]
>>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets)
'C0A80001'
>>> int(_, 16)
3232235521
>>>
>>> width = 5
>>> for num in range(5,12): 
...     for base in 'dXob':
...         print('{0:{width}{base}}'.format(num, base=base, width=width), end=' ')
...     print()
...
    5     5     5   101
    6     6     6   110
    7     7     7   111
    8     8    10  1000
    9     9    11  1001
   10     A    12  1010
   11     B    13  1011
```





### str.maketrans()

maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。

**注：**两个字符串的长度必须相同，为一一对应的关系。

**注：**string keys in translate table must be of length 1

```
str.maketrans(intab, outtab)
```

- intab -- 字符串中要替代的字符组成的字符串。
- outtab -- 相应的映射字符的字符串。

返回字符串转换后生成的新字符串。

> ```
> Help on built-in function maketrans:
>
> maketrans(x, y=None, z=None, /)
>     Return a translation table usable for str.translate().
>     
>     If there is only one argument, it must be a dictionary mapping Unicode
>     ordinals (integers) or characters to Unicode ordinals, strings or None.
>     Character keys will be then converted to ordinals.
>     If there are two arguments, they must be strings of equal length, and
>     in the resulting dictionary, each character in x will be mapped to the
>     character at the same position in y. If there is a third argument, it
>     must be a string, whose characters will be mapped to None in the result.
> ```

```python
# python 3.X Example

# str.maketrans({dict})				one argument dictionary

>>> str.maketrans({"1":"X", "2":"Y"})
{49: 'X', 50: 'Y'}

>>> S = "12345abcde!!!"
>>> table1 = str.maketrans({"1":"X", "2":"Y"})
>>> S.translate(table1)			# string keys in translate table must be of length 1
'XY345abcde!!!'
=============================================================================================

# str.maketrans(str1, str2) 		two argument string

>>> A = "12345"
>>> B = "abcde"
>>> print(str.maketrans(A, B))
{49: 97, 50: 98, 51: 99, 52: 100, 53: 101}

>>> S = "12345abcde!!!"
>>> table2 = str.maketrans("abc", "ABC")
>>> S.translate(table2)
'12345ABCde!!!'
=============================================================================================

# str.maketrans(str1, str2, str3)	three argument string

>>> str.maketrans("a", "1", "iop")
{112: None, 97: 49, 111: None, 105: None}
>>> str.maketrans("", "", "12345")
{49: None, 50: None, 51: None, 52: None, 53: None}

>>> S = "12345abcde!!!"
>>> table3 = str.maketrans("!", "@", "12345")
>>> S.translate(table3)
'abcde@@@'

>>> tableDel = str.maketrans("", "", "abcde")
>>> S.translate(tableDel)
'12345!!!'
```









### str.replace()

replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。

```
str.replace(old, new[, max])
```

- old -- 将被替换的子字符串。
- new -- 新字符串，用于替换old子字符串。
- max -- 可选字符串, 替换不超过 max 次

返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。

> **replace**(...)
>
> ​    S.replace(old, new[, count]) -> str
>
> ​    
>
> ​    Return a copy of S with all occurrences of substring
>
> ​    old replaced by new.  If the optional argument count is
>
> ​    given, only the first count occurrences are replaced.

```
>>> S = 'Spam'
>>> S.replace('pa', 'XYZ') 		# Replace occurrences of a string in S with another
'SXYZm'
>>> S 
'Spam'
```



### str.split()

split()通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串

```
str.split(str="", num=string.count(str))
```

- str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。
- num -- 分割次数。

返回分割后的字符串列表。

> **split**(...)
>
>     S.split(sep=None, maxsplit=-1) -> list of strings
>
>     
>
>     Return a list of the words in S, using sep as the
>
>     delimiter string.  If maxsplit is given, at most maxsplit
>
>     splits are done. If sep is not specified or is None, any
>
>     whitespace string is a separator and empty strings are
>
>     removed from the result.

```
#!/usr/bin/python3

str = "this is string example....wow!!!"
print (str.split( ))
print (str.split('i',1))
print (str.split('w'))
```

```
['this', 'is', 'string', 'example....wow!!!']
['th', 's is string example....wow!!!']
['this is string example....', 'o', '!!!']
```



### str.translate()

`translate()` 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到 del 参数中。

```
str.translate(table[, deletechars]);
```

- table -- 翻译表，翻译表是通过maketrans方法转换而来。
- deletechars -- 字符串中要过滤的字符列表。

返回翻译后的字符串。

> ```
> # python 2.X
>
> Help on method_descriptor:
>
> translate(...)
>     S.translate(table [,deletechars]) -> string
>     
>     Return a copy of the string S, where all characters occurring
>     in the optional argument deletechars are removed, and the
>     remaining characters have been mapped through the given
>     translation table, which must be a string of length 256 or None.
>     If the table argument is None, no translation is applied and
>     the operation simply removes the characters in deletechars.
> ```

> ```
> # python 3.X
>
> Help on method_descriptor:
>
> translate(...)
>     S.translate(table) -> str
>     
>     Return a copy of the string S, where all characters have been mapped
>     through the given translation table, which must be a mapping of
>     Unicode ordinals to Unicode ordinals, strings, or None.
>     Unmapped characters are left untouched. Characters mapped to None
>     are deleted.
> ```

```python
# python 2.X

>>> s = "1234asdf"
>>> s.translate(None, "12")
'34asdf'

==================================================================================================
# python 3.X

>>> S = "12345abcde!!!"
>>> table3 = str.maketrans("!", "@", "12345")		# translated using table
>>> S.translate(table3)
'abcde@@@'

>>> tableDel = str.maketrans("", "", "abcde")		# del "a","b","c","d","e"
>>> S.translate(tableDel)
'12345!!!'
```





### ...

### ...

### ...



## String Method Examples

### Changing String

#### 1. make a new text value from an existing string

you construct a new string with operations such as slicing and concatenation.

```
>>> S = 'spammy'
>>> S = S[:3] + 'xx' + S[5:]		# Slice sections from S
>>> S 
'spaxxy'
```

```
>>> S = "abcde"
>>> id(S)
4323524480
>>> S = S.replace("cd","mn")		# Replace all cd with mn in S
>>> S
'abmne'
>>> id(S)
4324167784
```

#### 2. The replace method 

 **replace returns a new string object** 

is more general than this code implies. It takes as arguments the original substring (of any length) and the string (of any length) to replace it with, and performs a global search and replace:

```
>>> 'aa$bb$cc$dd'.replace('$', 'SPAM') 
'aaSPAMbbSPAMccSPAMdd'
```

If you need to replace one fixed-size string that can occur at any offset, you can do a replacement again, or search for the substring with the string **find method** and then slice:

```
>>> S = 'xxxxSPAMxxxxSPAMxxxx'
>>> where = S.find('SPAM') 			# Search for position
>>> where 							# Occurs at offset 4 
4
>>> S = S[:where] + 'EGGS' + S[(where+4):]
>>> S 
'xxxxEGGSxxxxSPAMxxxx'
```

use replace with a third argument:

```
>>> S = 'xxxxSPAMxxxxSPAMxxxx'
>>> S.replace('SPAM', 'EGGS')		# Replace all		
'xxxxEGGSxxxxEGGSxxxx'

>>> S.replace('SPAM', 'EGGS', 1) 	# Replace one
'xxxxEGGSxxxxSPAMxxxx'
```

> Notice that replace returns a new string object each time. Because strings are immutable
>

**make multiple changes to it without generating a new copy for each change:**

```
>>> S = 'spammy'
>>> L = list(S)
>>> L 
['s', 'p', 'a', 'm', 'm', 'y']

>>> L[3] = 'x'		# Works for lists, not strings
>>> L[4] = 'x'
>>> L ['s', 'p', 'a', 'x', 'x', 'y']
```

after your changes, you need to convert back to a string (e.g., to write to a file), use the string join method to “implode” the list back into a string:

```
>>> S = ''.join(L)
>>> S
'spaxxy'
```

> join puts the strings in a list (or other iterable) together, with the delimiter between list items; in this case, it uses an empty string delimiter to convert from a list back to a string. More generally, any string delimiter and iterable of strings will do:
>
> ```
> >>> 'SPAM'.join(['eggs', 'sausage', 'ham', 'toast']) 'eggsSPAMsausageSPAMhamSPAMtoast'
> ```



### Parsing Text



















